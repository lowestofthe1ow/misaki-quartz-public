{"Term-1-Year-1/CCICOMP/(Q&A)-Data-representation":{"title":"(Q&A) Data representation","links":["Term-1-Year-1/CCICOMP/Data-representation"],"tags":["ccicomp"],"content":"See also: Data representation\nRepresent +24 in 6-bit sign-and-magnitude §\n  0   1   1   0   0   0\n  +  16   8   4   2   1\n\n\nRepresent +24 in 6-bit one’s complement §\n  0   1   1   0   0   0\n  +  16   8   4   2   1\n\n\nRepresent +24 in 6-bit two’s complement §\n  0   1   1   0   0   0\n  +  16   8   4   2   1\n\n\nRepresent −30 in 8-bit sign-and-magnitude §\n  1   0   0   1   1   1   1   0\n  -  64  32  16   8   4   2   1\n\n\nRepresent −30 in 8-bit one’s complement §\n  0   0   0   1   1   1   1   0\n  1   1   1   0   0   0   0   1\n  -  64  32  16   8   4   2   1\n\n\nRepresent −30 in 8-bit two’s complement §\n  0   0   0   1   1   1   1   0\n  1   1   1   0   0   0   1   0\n  -  64  32  16   8   4   2   1\n\n\nCompute the range for 10-bit sign-and-magnitude §\n−(2n−1)+1,2n−1−1\n−(29)+1,29−1\n−511,+511\n\nCompute the range for 10-bit one’s complement §\n−(2n−1)+1,2n−1−1\n−(29)+1,29−1\n−511,+511\n\nCompute the range for 10-bit two’s complement §\n−(2n−1),2n−1−1\n−(29),29−1\n−512,+511\n\nWhat is the normalized form for IEEE SP? §\n±1.M×2E′−127\n\nWhat is the normalized form for IEEE DP? §\n±1.M×2E′−1023\n\nWhat is the bit distribution for IEEE SP? §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSymbolComponentBit sizeSSign bit1 bitE’Exponent8 bitsMMantissa23 bits\n\n\n\n\nExample:\nSEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM\nHex:\nHHHH HHHH\n\n\nWhat is the bit distribution for IEEE DP? §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSymbolComponentBit sizeSSign bit1 bitE’Exponent11 bitsMMantissa52 bits\n\n\n\n\nExample:\nSEEE EEEE EEEE MMMM MMMM MMMM .... MMMM\nHex:\nHHHH HHHH HHHH HHHH\n\n"},"Term-1-Year-1/CCICOMP/Application-software":{"title":"Application software","links":[],"tags":["ccicomp"],"content":"Applications §\nAn application, or app, sometimes called application software, consists of programs designed to make users more productive, conduct business, or provide entertainment.\n\nProductivity software §\nProductivity software includes programs that allow people to perform various tasks required at home, school, and business.\n\nWord processors §\nCreate and edit documents.\n\nSpreadsheets §\nMake calculations and perform numerical analyses.\n\nPresentation software §\nProduce high-quality slide presentations.\n\nNote-taking software §\nTake down and organize free-form notes.\n\nPersonal information manager §\nManage e-mail, contacts, calendars, and tasks in one place.\n\nPersonal finance software §\nManage daily finances (e.g., automated bills payments, cash transfer, monitor budget, etc).\n\nDatabases §\nStore and organize data, perform complex data querying.\n\nSoftware suite §\nFor proprietary software, it’s cheaper to buy a software suite than to buy each program individually. Productivity software suites include:\n\nMicrosoft Office §\nThe standard proprietary software suite for Windows. A version is also available for Apple computers.\n\nApache OpenOffice §\nAn open-source productivity suite that provides functionality similar to that of Microsoft Office.\n\nApple iWork §\nA productivity suite made especially for Apple computers.\n\nBusiness software §\nBusiness software assists users with day-to-day business operational tasks or enables them to provide services to customers.\n\nSoftware for small businesses §\nAccounting Software §\nHelps business owners manage finances by providing tools for tracking accounts receivable and accounts payable, inventory management, payroll, and billing tools. Examples include Intuit QuickBooks and Sage Peachtree.\n\nDesktop Publishing (DTP) Software §\nProvides tools to prepare and design newsletters, catalogs, annual reports, or other large, complicated publications. Examples include Adobe InDesign.\n\nWebpage Authoring Software §\nProvides wizards, templates, and reference material to design interactive web pages. Examples include Adobe Dreamweaver.\n\nProject management §\nCreates scheduling charts to plan and track specific tasks and to coordinate resources.\n\nE-commerce §\nFacilitates website creation and hosting services, shopping cart setup, and credit card—processing services.\n\nCustomer relationship management (CRM) §\nStores sales and client contact information in one central database.\n\nComputer-aided design (CAD) §\nCreates automated designs, technical drawings, and 3-D model visualizations for architecture, automotive, aerospace, and medical engineering industries.\n\nEnterprise resource planning (ERP) §\nControls many “back office” operations and processing functions such as billing, production, inventory management, and human resources management.\n\nVertical market §\nAddresses the needs of businesses in a specific industry or market such as real estate, banking, and automotive industries.\n\nMedia and entertainment software §\nMedia software are specialty software required to produce computer games, graphic designs, animations, music, and videos.\n\nImage editing software §\nCommonly provide one or more of the following tools to create or manipulate images, e.g.:\n\nModifications to digital photos (e.g., red-eye modifying, contrast, sharpness).\nPainting tools (e.g., brushes, pens, and artistic media).\nSpecial effects for image processing (image filters, removing background, face swaps).\nExamples include GIMP, Adobe Photoshop, Corel Paintshop.\n\n\nVideo editing software §\nProvide means to edit and refine videos and commonly feature the following core features:\n\nVideo splicing, splitting and trimming.\nEncoding and compression of video using different formats.\nSpecial effects.\nAdd voiceovers and BGM.\nAdding transition effects and text.\nExamples include iMovie, Adobe Premiere, PowerDirector.\n\n\nAudio editing software §\nAudio editing software provide tools to edit or produce audio files. The following are common features:\n\nBasic editing: Mixing tracks, cutting dead air, splicing audio.\nAudio processing effects: Enhancing bass/treble, removing vocals, removing background noise.\nConvert audio files to different uncompressed (e.g., WAV) or compressed formats (e.g., MP3, AAC).\nCompose soundtracks with virtual instruments, voice recorders, synthesizers, and special audio effects.\nExamples: Audacity, MAGIX Music Maker.\n\n\nComputer games §\nComputer games provide entertainment with a wide variety of game genres such as:\n\nReal-time strategy (RTS).\nFirst-person / third-person shooters (FPS / TPS).\nMultiplayer online battle arenas (MOBA).\nRole-playing (RPG).\nSimulation.\nSports.\nPuzzles and party games.\nAction adventure.\n\n\nEducational software §\nCourse Management Software §\nCourse management software provides a platform to deliver online learning materials and manage online classes.\n\nSimulation Programs §\nSimulation programs mimic the behavior of real-world objects or events to allow users to experience them in a controlled environment.\n\nEmulator Programs §\nEmulator programs duplicate the hardware and OS features of a real device and are commonly used to run software outside its native computer platform.\n"},"Term-1-Year-1/CCICOMP/Boolean,-logic-gates,-and-bitwise-operations":{"title":"Boolean, logic gates, and bitwise operations","links":["Term-1-Year-1/CCICOMP/Data-representation","Term-1-Year-1/CCICOMP/Boolean,-logic-gates,-and-bitwise-operations","Term-1-Year-1/CCICOMP/Integer-representation"],"tags":["ccicomp"],"content":"See also: Data representation\nLogic operations §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOperationInputSymbolOutputBufferAANOTAAˉANDA,BABORA,BA+BNANDA,BABˉXORA,BAˉB+ABˉ\n\n\n\n\nLogic operations based on Boolean algebra may be used on Boolean data to produce a result of either true (1) or false (0). They form the basis of logic gates - circuits serving as basic building blocks of CPU that can perform a processing function on a single binary electrical signal, or bit.\n\nNOT operation §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAY0110\n\n\n\n\nA NOT operation negates the input expression and is also referred to as an inverter.\nWritten as Y=A′ or Y=Aˉ.\n\nAND operation §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABY000010100111\n\n\n\n\nThe AND operation is also known as an “all or nothing” gate since it will only output a true condition if all its inputs are true.\nWritten as Y=AB.\n\nOR operation §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABY000011101111\n\n\n\n\nThe OR operation is often referred to as an “any or all” gate. It outputs a true condition if at least one of its conditions is true.\nWritten as Y=A+B.\n\nXOR operation §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABY000011101110\n\n\n\n\nThe XOR operation is also known as exclusive-OR. It outputs a true condition if the input variables have an odd number of binary 1’s (odd function).\nWritten as Y=A⊕B, or represented in terms of AND, OR, and NOT as Y=A′B+AB′.\n\nBitwise operations §\nOn computers, logic operators are often implemented as bitwise operations which perform logic operations on individual bits of a bit string.\n\nBitwise NOT §\nA NOT operation flips individual bits (e.g. for getting one’s and two’s complement):\nNOT 1111 0011b\n  = 0000 1100b\n\n\nBitwise AND §\nAn AND operation checks each pair of bits and returns 1 for that pair if both are true. This is used for checking if a number is odd, e.g.:\n    0010 0011b\nAND 0000 0001b\n  = 0000 0001b (true; odd)\n\n\nBoolean functions §\nA Boolean function is an expression formed with binary variables, binary or unary operators, parentheses, and an equal sign. The result of the function can be either 0 or 1, e.g.:\nF=XˉYˉZ+XYˉZˉ+XˉYZ+XYˉZ\nComplex binary operations can be expressed as Boolean functions which can later be used as basis to design the processing circuits of a CPU.\n\nSingle-bit adder §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nABSumCarry0000011010101101\n\n\n\n\nGiven that single-bit binary addition works as shown above, the sum may be represented as A′B+AB′ (“‘NOT A’ AND ’B’” OR “’A’ AND ‘NOT B’”), while the carry may be represented as  AB (A AND B).\n"},"Term-1-Year-1/CCICOMP/Character-representation":{"title":"Character representation","links":["Term-1-Year-1/CCICOMP/Character-representation"],"tags":["ccicomp"],"content":"Character representation §\nCharacter data cannot be represented directly in a computer because computers process only bits; such data is represented indirectly by defining a table that assigns a numeric value to each character.\n\nCoding methods §\nCharacters use table-based substitution of one set of symbols or values.\nAll coding methods share these important characteristics:\n\nAll users must use the same coding and decoding methods.\nThe coded values must be capable of being stored or transmitted.\nA coding method represents a tradeoff among compactness, number of representable characters, and standardization.\n\n\nAmerican Standard Code for Information Interchange (ASCII) §\n\n7-bit encoding format, with 1 bit for parity. Coding table has at least 128 available characters.\nNewer computers may use all 8-bits, resulting in an additional 128 characters used by manufacturers to define multinational or graphical characters\nSupported by a majority of operating systems\n\n\nUnicode §\n\nCoding table that uses 16-bit or 32-bit codes to represent characters\nCreated to extend the range limit of 8-bit coding methods to represent characters of different languages (e.g. Chinese, Arabic, Japanese, etc.)\nCurrently, ASCII is designated as a subset of Unicode.\n\n\nDevice control §\nWhen text is printed or displayed on an output device such as a monitor or printer, it’s often formatted in a particular way (e.g. lines and paragraphs). Coding methods define device control codes used for text formatting by placing them immediately before or after the characters they modify.\n\nCarriage return (CR) §\nMoves the print head or insertion point to the beginning of a line.\n\nLine feed (LF) §\nMoves the print head or insertion point down one line.\n\nOperations on characters §\nCharacters are usually handled similarly to unsigned integers by the CPU. Thus, integer instructions (add, copy, compare equal) often have similar effect to unsigned integers and characters. However, nonequality comparisons compare the characters numeric codes and hence are dependent on their collating sequence, e.g.:\n&#039;A&#039; != &#039;a&#039;\n&#039;a&#039; &gt; &#039;b&#039;\n\n"},"Term-1-Year-1/CCICOMP/Data-representation":{"title":"Data representation","links":["Term-1-Year-1/CCICOMP/Introduction-to-number-systems","Term-1-Year-1/CCPROG1/Tokens-and-token-classification","Term-1-Year-1/CCICOMP/Integer-representation","Term-1-Year-1/CCICOMP/Character-representation"],"tags":["ccicomp"],"content":"\nComputer systems represent data electrically and process it with electrical switches with 2 states (on / off) that express binary data. Computers deal with all sorts of non-numeric data (e.g. strings, images, video), but they are internally still represented by a set of binary numeric values.\nFactors for representation §\nData size and Range §\nData size describes the number of bits (from “binary digit”) used to represent a numeric value which directly affects the range of values that can be represented. Smaller size indicates a smaller range.\n\nAccuracy §\nAccuracy or precision of representation increases with the number of data bits used. Some calculations can generate quantities too large or too small to be contained in a machine’s finite circuitry (e.g. 1 / 3 = 1.3333…), meaning it must be stored as an approximate finite value. More bits leads to less error but consumes more space.\n\nData types §\nA data type specifies:\n\nthe kind of values that can be assumed by a variable of that type\nthe range of values that can be assumed by a variable of that type\nthe amount of memory (in bytes) needed by a variable to store a value of that type\nIncludes integers, floating-point numbers, characters, strings\n\n\nIntegers §\n\nRepresents numerical integers, i.e., the number zero, a positive natural number or a negative integer with a minus sign.\nTypically represented as fixed-point, i.e., with a finite amount of decimal precision.\n\nThis means, as opposed to floating-point numbers, the radix point is fixed in its position to the right of the least significant bit.\n\n\n\n\nUnsigned integers §\n\nPositive integers only\nFixed number of bits n; values range from 0 to 2n−1\n\n___ ___ ___ ___ ___ ___ ___ ___   .\n128  64  32  16   8   4   2   1 radix\n\n\nSigned integers §\n\nPositive or negative integers\nDifferent representations using n bits\n\nSign and magnitude\nOne’s complement\nTwo’s complement\n\n\n\n\nFloating-point numbers §\n\n“Floating” or moving radix point\nSingle-precision (32-bit)\nDouble precision (64-bit)\n\n\nCharacters §\n\nEnglish and many other languages use alphabetic letters, numerals, punctuation marks, and a variety of other special-purpose symbols, such as $ and &amp;. (each symbol is a character).\nEncoded through various coding methods.\n\n\nString §\n\nSeries of characters, stored in C as an array of characters. For instance, the string Hello! encoded using ASCII is stored as 48 65 6C 6C 6F 21.\n\n\nBoolean §\n\nTrue or false, expressed as 0 (false) or 1 (true)\nWhen the processing function is a comparison operation, the output signal represents a Boolean result which is often used by other instructions as input (e.g. a conditional branch in a program).\nThe Boolean data type requires only a single bit for representation, but to simplify processor design and implementation, most CPU designers use an integer coding format to represent Boolean values.\n\nCorresponding integer value of zero is processed as false\nAny nonzero value is processed as true\n\n\n\n\nBinary representation §\n\nPositional number system used by computers to represent any form of data\nUses radix or base 2 (0 = off, 1 = on)\nBinary numbers represented as on/off electrical signals can be transported reliably between computer systems and their components\nBinary numbers represented as electrical signals can be processed by two-state electrical devices that are easy to design and fabricate\nCorrespond directly with Boolean logic – a form of logic that evaluates sequences of statements as ‘true’ or ‘false’\n\n"},"Term-1-Year-1/CCICOMP/Floating-point-representation":{"title":"Floating-point representation","links":["Term-1-Year-1/CCICOMP/Data-representation"],"tags":["ccicomp"],"content":"See also: Data representation\nIEEE Single Precision §\n\nNormalized form: ±1.M×2E′−127\n\nRepresent the number in binary\n\n-6.0625d = -110.0001b\n\n\nGet the normalized form: ±1.M×2E′−127\n\nNormalized form: -1.100001*2^2\n\n\nIdentify S (1 bit), E′ (8 bits), and M (23 bits), then represent as needed by padding zeros to the right.\n\nS  = 1\nE&#039; = 2 + 127 = 129 = 1000 0001\nM  = 100001 + trailing zeroes = 100 0010 0000 0000 0000 0000\n\nRepresentation in binary:\nSEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM\n1100 0000 1100 0010 0000 0000 0000 0000\n\nRepresentation in hexadecimal:\n1100 0000 1100 0010 0000 0000 0000 0000\n   C    0    C    2    0    0    0    0\n= COC2 0000h\n\n\nIEEE Double Precision §\n\nNormalized form: ±1.M×2E′−1023\n\nRepresent the number in binary\n\n9.625d = 1001.101b\n\n\nGet the normalized form: ±1.M×2E′−1023\n\nNormalized form: 1.001101*2^3\n\n\nIdentify S (1 bit), E′ (11 bits), and M (52 bits), then represent as needed by padding zeros to the right.\n\nS  = 0\nE&#039; = 2 + 1023 = 1026 = 100 0000 0010\nM  = 001101 + trailing zeroes\n\nRepresentation in binary:\nSEEE EEEE EEEE MMMM MMMM MMMM .... MMMM\n0100 0000 0010 0011 0100 0000 .... 0000\n\nRepresentation in hexadecimal:\n0100 0000 0010 0011 0100 0000 .... 0000\n   4    0    2    3    4    0 ....    0\n= 4023 4000 0000 0000\n\n"},"Term-1-Year-1/CCICOMP/Integer-representation":{"title":"Integer representation","links":["Term-1-Year-1/CCICOMP/Data-representation","Term-1-Year-1/CCICOMP/Integer-representation"],"tags":["ccicomp"],"content":"See also: Data representation\nSign and magnitude §\n\nLeftmost bit is used as a sign bit, i.e., 1 if negative and 0 if positive\nFixed number of bits n; values range from −(2n−1)+1 to 2n−1−1\n\n___ ___ ___ ___ ___ ___ ___ ___   .\n+/-  64  32  16   8   4   2   1 radix\n\n\nOne’s complement §\nIf the integer is positive:\n\nRepresent the number in binary using n bits\nCheck the most significant bit\n\nIf 0, the number can be represented\nIf 1, the number is out of range and must be represented with n+1 bits instead\n\n\n\n  0   0   1   0   1   0   1   0\n  +  64  32  16   8   4   2   1\n= +42\n\nIf the integer is negative:\n\nRepresent the number in binary using n bits\nFlip all bits, i.e., change 0 to 1 and vice versa\nCheck the most significant bit\n\nIf 1, the number can be represented\nIf 0, the number is out of range and must be represented with n+1 bits instead\n\n\n\n  1   1   0   1   0   1   0   1\n  -  64  32  16   8   4   2   1\n= -42\n\n\nFixed number of bits n; values range from −(2n−1)+1 to 2n−1−1\n\n\nBinary arithmetic with the one’s complement §\n\nAddition of two positive integers is the same as normal binary addition.\nSubtraction involves addition with the one’s complement representation of negative numbers\n\n\nTwo’s complement §\nIf the integer is positive, follow the same procedure as the one’s complement and sign and magnitude representations:\n\nRepresent the number in binary using n bits\nCheck the most significant bit\n\nIf 0, the number can be represented\nIf 1, the number is out of range and must be represented with n+1 bits instead\n\n\n\n  0   0   1   0   1   0   1   0\n  +  64  32  16   8   4   2   1\n= +42\n\nIf the integer is negative:\n\nRepresent the number in binary using n bits\nFrom right to left:\n\nCopy all 0’s until the first occurrence of 1, then copy 1\nFlip all remaining bits, i.e., change 0 to 1 and vice versa\nOR\nFlip all bits, i.e., change 0 to 1 and vice versa\nAdd 1\n\n\nCheck the most significant bit\n\nIf 1, the number can be represented\nIf 0, the number is out of range and must be represented with n+1 bits instead\n\n\n\n  0   0   1   1   1   1   0   0   # Initial binary representation\n  1   1   0   0   0   0   1   1   # Flip each bit\n  1   1   0   0   0   1   0   0   # Add 1\n  -  64  32  16   8   4   2   1   \n\n"},"Term-1-Year-1/CCICOMP/Internetworking":{"title":"Internetworking","links":["Term-1-Year-1/CCICOMP/Internetworking"],"tags":["ccicomp"],"content":"Computer networks §\nA computer network refers to the connection of two or more computers through software and hardware, facilitating communication between them. Each connected device, whether a computer, peripheral (e.g., printer or game console), or network device (e.g., router), is termed a node.\n\nNetworks provide various advantages, including:\n\nSharing an Internet connection\nSharing printers and other peripherals\nSharing files\nCommon communications\n\n\n\nNetwork performance §\nNetwork performance is usually measured as bandwidth and throughput, which in turn are measured in bits per second (bps)\n\nData transfer rate §\nAlso known as bandwidth, data transfer rate represents the maximum speed of data transmission between network nodes.\n\nThroughput §\nThroughput refers to the actual speed achieved and is often less than the bandwidth.\n\nNetwork communication mechanics §\nPackets §\nA computer network operates similarly to a complex mail system, transporting messages as packets of bits and bytes.\n\nAddress §\nEach node requires a unique address and must adhere to communication rules.\n\nNetwork infrastructure §\nPackets traverse the network infrastructure from source to destination.\n\nNetwork components §\nA network’s complexity can range from a simple connection between two computers to a global collection of interconnected networks. Two broad categories of physical components in a network are transmission media and devices, including infrastructure and end devices.\n\nTransmission media §\nCommunication across a network from source to destination occurs through media such as metallic wires (e.g., copper), glass (fiber optic cables), and wireless transmission.\n\nElectrical media §\nMost common and least expensive\n\nTwisted pair §\nMade up of copper wires twisted around each other and surrounded by a plastic jacket.\n\nSeveral grades of twisted pairs are available, including:\n\nCat 5e (up to 1 Gbps)\nCat 6 and Cat 6a (up to 10 Gbps)\n\n\n\nCoaxial cables §\nConsists of a single copper wire surrounded by layers of plastic (hence “coaxial”)\n\nCoaxial cables are commonly found on TVs, cable broadband connections, and other networks\n\n\nOptical fiber §\nContains strands of light-conducting filaments made of plastic or glass with a tough plastic coating for protection from physical damage. Although expensive and fragile, and difficult to install, optical fibers offer high bandwidth and long-distance transmission capabilities.\n\nWireless media §\nConveys signals using radio frequency with the use of an antenna that enables greater mobility, with the downside of having lower bandwidth than wired connections.\n\nWireless media is easily affected by interference from other wireless and radio devices. Its throughput is also affected by distance and physical barriers\n\n\nEnd devices §\nEvery computer connected to a network is an end device or host; i.e., it is where a message originates from or where a message is received. End devices include servers and clients\n\nServers §\nServers provide services and information to end devices on the network. Examples include email servers, web servers, or file servers.\n\nNetwork printers §\nNetwork printers provide centralized printing that can be accessed by different networked users\n\nNetwork-attached storage (NAS) §\nNAS provides centralized and dedicated file storage on the network\n\nNetwork interface card (NIC) §\nAn NIC or network port enables an end device to connect to a network.\n\nClients §\nClients send requests to the servers to retrieve information such as a web page from a web server or to ask for a task to be performed such as sending an email.\n\nNetwork Infrastructure Devices §\nInfrastructure devices interconnect end devices, manage data flow, and include switches, wireless access points, routers, and firewalls.\n\nSwitches §\n\nSwitches connect devices together using cables to form a network\n\nWireless access points (WAP) §\n\nWireless access points connect wireless devices together to form a network\n\nRouters §\n\nRouters connect networks together and calculate the best paths to move (route, hence “router”) data between them\n\nFirewalls §\n\nFirewalls perform filtering in a network to block unwanted data\n\nCommunication rules §\nCommunication requires a set of rules, such as:\n\nAn identified sender and receiver\nUsing a common language\nMethod of communication (e.g., mail, face to face, messaging)\n\n\nNetwork communication rules §\nWhen communicating over a network, devices follow a set of standards and protocols to ensure compatibility and orderly communications. These rules include:\n\nHow messages should be packaged\nHow addresses should be formatted\nHow fast messages can be sent\n\n\n\nSome popular standards include:\n\nEthernet (for wired devices)\n802.11 Wireless Ethernet (for wireless devices)\nInternet Protocol (IP)\n\n\n\nAddressing §\nDevices use MAC and IP addresses for identification within a network, requiring unique addresses for proper communication (i.e., to receive packets).\nTo communicate on a network, a device must the same network number as the network it is connected to, and must have a unique host number within that network.\nTo communicate with destinations outside its network, a device must additionally be set with a default gateway\n\nMAC address §\nA MAC address is a permanent address that uniquely identifies a device whichever network it may join (similar to your name)\n\nIP address §\nAn IP address is a temporary address that uniquely identifies a device within a network (similar to your student ID). It is paired with a subnet mask to differentiate the network number and its host number within the network\n\nTypes of Networks §\nCommon network types include Local Area Networks (LANs), Wireless LANs (WLANs), and Wide Area Networks (WANs).\n\nLocal area networks §\nThese networks span small geographic areas, providing high-speed bandwidth within homes, schools, or offices. They are usually owned or managed by a single organization or individual and provide high speed bandwidth to end devices and infrastructure devices within the network.\n\nWANs §\nInterconnecting LANs over larger regions, WANs offer slower speed links between LANs. They are usually owned and managed by multiple service providers.\n\nThe Internet §\nThe Internet is a worldwide collection of interconnected LANs and WANs. LANs are connected to each other using WANs. WANs are then connected to each other using copper wires, fiber optic cables, and wireless transmissions. The Internet is not owned by any individual or group; however, global organizations and consortiums help maintain its structure\n\nConnecting to the Internet §\nBusinesses and individuals connect to the Internet through dedicated connections or services from Internet service providers (ISPs). ISPs offer broadband Internet connection services, allowing users to access the Internet.\n\nCable §\nTransmission Medium: Coaxial cables, similar to cable TV wire\nCharacteristics: Cable connections are shared, so speed can drop during high-usage periods\nSpeeds: Average: 10 Mbps, Maximum: 30 Mbps\n\nDSL §\nTransmission Medium: Copper wire phone line\nCharacteristics: Speed drops as distance from the main signal source increases\nSpeeds: Average: 3.7 Mbps, Maximum: 35 Mbps\n\nFiber §\nTransmission Medium: Optical fiber\nCharacteristics: Transmits data via light signals, which do not degrade over long distances\nSpeeds: Average: 50 Mbps, Maximum: 500 Mbps\n\nMobile (3G/4G/5G) §\nTransmission Medium: Radio frequency - uses the same cellular network that cell phones use\nCharacteristics: Speed drops as users and distance from cell towers increase. Also affected by physical obstacles\nSpeeds:\n\n3G: Average: 3 Mbps\n4G: Average: 20 Mbps\n5G: Average: 140 Mbps\n\n"},"Term-1-Year-1/CCICOMP/Introduction-to-number-systems":{"title":"Introduction to number systems","links":["Term-1-Year-1/CCICOMP/Data-representation"],"tags":["ccicomp"],"content":"\nComputers process data into information and work exclusively with numbers. All data is represented in binary form, which represents data in combinations of 1’s and 0’s.\nWhat is a number system? §\n\nA way of representing numerical values\nHas its own arithmetic method\nAny arbitrary numerical value can be represented by a fixed set of symbols consisting of r elements (also known as radix or base).\nThe largest-valued symbol always has a magnitude of one less than the radix.\nEach variable that denotes a digit is assigned a weight dependent on its position relative to a radix point.\n\n\nDifferent number systems §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBaseSystemBaseSystem1Unary11Undecimal2Binary12Duodecimal3Ternary13Tridecimal4Quatenary14Tetradecimal5Quinary15Pentadecimal6Senary16Hexadecimal7Septenary18Octodecimal8Octal20Vigesimal9Nonary24Tetravigesimal10Decimal25Pentavigesimal\n\nDecimal number system §\n\nRadix/Base: 10\nSymbols: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\nWritten as: 25, 25d​ or 2510​\nEach digit is weighted by powers of 10\n\n\nBinary number system §\n\nRadix/Base: 2\nSymbols: 0, 1\nWritten as: 1011b​ or 10112​\nEach digit is weighted by powers of 2\n\n\nOctal number system §\n\nRadix/Base: 8\nSymbols: 0, 1, 2, 3, 4, 5, 6, 7\nWritten as: 327o​ or 3278​\nEach digit is weighted by powers of 8\n\n\nHexadecimal number system §\n\nRadix/Base: 16\nSymbols: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F\nWritten as: 5C8h​ or 5C816​\nEach digit is weighted by powers of 16\n\n\nBase conversion §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFromToProcessBinaryDecimalMultiply each binary digit by increasing powers of 2 then addOctalDecimalMultiply each octal digit by increasing powers of 8 then addHexadecimalDecimalMultiply each hex digit by increasing powers of 16 then addDecimalBinaryContinuous division by 2, remainders will be binary digitsDecimalOctalContinuous division by 8, remainders will be octal digitsDecimalHexadecimalContinuous division by 16, remainders will be hex digitsBinaryOctalGroup by 3 digits from the right, convert to corresponding octal digitBinaryHexadecimalGroup by 4 digits from the right, convert to corresponding hex digitOctalBinaryConvert each octal digit to corresponding 3-digit binary valueHexadecimalBinaryConvert each hex digit to corresponding 4-digit binary value\n\nBinary-decimal, octal-decimal, hexadecimal-decimal §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1011×221×211×20401\n\n\n\n\nEach digit appearing to the left of the binary point represents a value times an increasing power of the relevant base or radix. In this case, 4+0+1=5, i.e.:\n101b​=5d​\n\nContinuous division §\n\n\nContinuous multiplication §\n\n\nBinary-octal and binary-hexadecimal §\nOne octal digit is equal to three binary digits.\nOne hexadecimal digit is equal to four binary digits.\n\n"},"Term-1-Year-1/CCICOMP/Memory-components":{"title":"Memory components","links":["Term-1-Year-1/CCICOMP/Memory-components","Term-1-Year-1/CCICOMP/System-unit-components"],"tags":["ccicomp"],"content":"Internal memory §\nAlso known as primary memory; refers to memory that stores small amounts of data that can be accessed quickly while the computer is running.\nWhen the processor needs an instruction or data, it searches memory in this order:\n\nLI cache\nL2 cache\nL3 cache (if it exists)\nRAM\nDelay is greater with each level of memory it must search. If the instruction or data is not found in primary memory, then it must search in secondary storage (e.g. hard disk or optical disc), which has a much slower speed.\n\n\nRandom access memory (RAM) §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTransistors per bitRelative access timePersistent?Sensitive?Relative costApplicationsSRAM61×YesNo1000×CacheDRAM010×NoYes1×Main memory, frame buffers\n\n\n\n\nAlso called main memory, consists of memory chips that can read from and written to by the processor. RAM is volatile, meaning it loses its contents when power is removed. Static RAM (SRAM) is faster and significantly more expensive than dynamic RAM (DRAM).\n\nStatic RAM (SRAM) §\nStatic RAM keeps data in the memory as long as power is supplied to the system. SRAM stores each bit in a bistable memory cell, i.e., it can stay indefinitely in either of two different voltage configurations, or states. Any other state will be unstable—starting from there, the circuit will quickly move toward one of the stable states.\n\n\nSuch a memory cell is analogous to an inverted pendulum. The pendulum is stable when it is tilted either all the way to the left or all the way to the right. From any other position, the pendulum will fall to one side or the other. This bistable nature allows SRAM memory cells to retain its value indefinitely, as long as it is kept powered. Even when a disturbance, such as electrical noise, perturbs the voltages, the circuit will return to the stable value when the disturbance is removed.\n\n\nRegisters §\nRegisters are small, high-speed storage locations that temporarily hold data and instructions inside the processor. They are the fastest form of memory and provide the processor with quick access to data, such as when:\n\nStoring the location from where the instruction was fetched,\nStoring an instruction while the control unit decodes it,\nStoring data while the ALU calculates it,\nStoring the results of a calculation.\n\n\nCache §\nCache is a form of high-speed storage that stores frequently used instructions and data and has\nlarger capacity than registers.\nThere are three levels of cache:\n\nL1 cache is built directly on the processor chip, has a very small capacity\nL2 cache is slightly slower than LI cache but has a larger capacity\n\nAdvanced transfer cache (ATC) is a type of L2 cache built directly on the processor chip making it perform faster\n\n\nL3 cache is a cache on the motherboard that is separate from the L2 cache; exists only on computers that uses ATC L2 cache\n\n\nDynamic RAM (DRAM) §\nDynamic RAM stores each bit as a charge on a capacitor. Unlike SRAM, a DRAM memory cell is very sensitive to any disturbance. When the capacitor voltage is disturbed, it will never recover. Exposure to light rays will cause the capacitor voltages to change. In fact, the sensors in digital cameras and camcorders are essentially arrays of DRAM cells.\n\nDRAM cell to lose its charge within a time period of around 10 to 100 milliseconds. Fortunately, for computers operating with clock cycle times measured in nanoseconds, this retention time is quite long. The memory system must periodically refresh every bit of memory by reading it out and then rewriting it.\n\n\nMemory modules §\nRAM chips usually reside on a memory module, which is a small circuit board. Memory slots on the motherboard hold memory modules.\n\nSingle inline memory module (SIMM) §\nSingle inline memory modules (SIMM) have pins on opposite sides of the circuit board that\nconnect together to form a single set of contacts\n\nDual inline memory module (DIMM) §\nDual inline memory modules (DIMM) have pins on opposite sides of the circuit board that do not\nconnect and thus form two sets of contacts\n\nRead only memory (ROM) §\nAs opposed to RAM, ROM is nonvolatile, meaning its contents are not lost when power is removed. ROM chips, called firmware, contain permanently written data or instructions, e.g., a computer or a mobile device’s start-instructions\n\nProgrammable ROM (PROM) §\nProgrammable ROM (PROM) is is a form of digital memory where the contents can be changed once after manufacture of the device. In other words, it is programmable by user using an external programming device only once (hence one-time programmable; OTP), after which the data becomes permanent and non-volatile.\n\nErasable PROM (EPROM) §\nEPROM is a form of PROM, i.e., its contents can be changed by the user using an external programming device. However, once programmed, an EPROM can be erased by exposing it to strong ultraviolet (UV) light source.\n\nElectrically erasable PROM (EEPROM) §\nEEPROM is a form of PROM, i.e., its contents can be changed by the user using an external programming device. However, EEPROM allows individual bytes to be erased and reprogrammed in-circuit (i.e., without the need to remove from the circuit board as with UV-erasable EPROM). It can clear entire blocks with a single operation.\n\nFlash storage is an application of EEPROM technology.\n\n\nExternal memory §\nA storage device (external memory or secondary storage) is the hardware that records or retrieves items to/from storage media.\n\nStorage capacity §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStorage termApprox. no. of bytesExact no. of bytesKilobyte (KB)1 thousand210Megabyte (MB)1 million220Gigabyte (GB)1 billion230Terabyte (TB)1 trillion240Petabyte (PB)1 quadrillion250Exabyte (EB)1 quintillion260Zettabyte (ZB)1 sextillion270Yottabyte (YB)1 septillion280\n\n\n\n\nCapacity is the number of bytes that a storage medium can hold\n\nStorage access time §\nStorage access time measures the amount of time it takes a storage device to locate an item on a storage medium. On the other hand, transfer rate refers to the speed at which data and instructions are transferred to/from a storage device. Transfer rates are measured in KBps (kilobytes per second), MBps (megabytes per second), or GBps (gigabytes per second).\n\nHard Disk §\nA hard disk, also called a hard disk drive (HDD), is a storage device that contains one or more flexible, circular platters that use magnetic particles to store data and instructions.\n\nThe storage capacity of hard disks varies and is determined by three factors: platter, composition of magnetic coating, and density\n\n\nPlatter §\nThe platter is made of aluminum, glass, or ceramic and has a thin coating of alloy material that allows data and instructions to be recorded magnetically on its surface.\n\nComposition of magnetic coating §\nThe composition of the magnetic coating on the platter is crucial for storage.\n\nLongitudinal recording aligns the magnetic particles horizontally around the surface of the disk.\nPerpendicular recording aligns the magnetic particles vertically, making much greater storage capacity possible.\n\n\nDensity §\nDensity refers to the number of bits in an area on a storage medium.\n\nFormatting §\nFormatting is the process of dividing the disk into tracks and sectors so that the OS can locate data on the disk easily. While the computer is running, the platters in the hard disk rotate at a high rate of speed. This spinning, which usually is 5400 to 15000 revolutions per minute (rpm), allows nearly instant access to all tracks and sectors on the platters. The platters continue to spin until power is removed, or slow down after a period of time to save power.\n\nTrack §\nA track is a narrow recording band that forms a full circle on the surface of the disk. The disk’s storage locations consist of wedge-shaped sections, which break the tracks into smaller arcs called sectors.\n\nSector §\nA sector can typically store 512 bytes of data.\n\nOptical Discs §\nAn optical disc is a type of storage medium that consists of a flat, round, portable disc made of metal, plastic, and lacquer that is written and read by a laser.\n\nFlash Memory Storage §\nFlash memory is a type of nonvolatile memory that can be erased electronically and rewritten. Flash memory chips are a type of solid-state media, consisting entirely of electronic components such as integrated circuits and containing no moving parts. The lack of moving parts makes flash memory more durable and shock-resistant than other types of media, such as magnetic disks or optical discs.\n\nUSB Flash Drives §\nUSB flash drives, sometimes called a thumb drive or pen drive, are flash memory storage devices that plug into a USB port on a computer or mobile device.\n\nSolid-State Drive §\nA solid-state drive (SSD) is a flash memory storage device that has its own processor to manage its storage. SSDs have several advantages over traditional (magnetic) hard disks: higher storage capacities, faster access time (up to 80 times faster), faster transfer rates, quieter operation, more durable, lighter weight, less power consumption (leading to longer battery life), less heat generation, and longer life. The disadvantages of SSDs are that data recovery in the event of failure can be more difficult and cost is higher per gigabyte.\n\nMemory Cards §\nA memory card is a removable flash memory storage device that is inserted into a slot in a computer, mobile device, or card reader/writer.\n\nCloud Storage §\nCloud storage is an Internet service that provides storage to computers and mobile device users. It is available for home and business users, with various degrees of storage services available. Cloud storage fee arrangements vary, depending on the user’s storage requirements.\n"},"Term-1-Year-1/CCICOMP/Software-development-tools-and-acquisition":{"title":"Software development tools and acquisition","links":["Term-1-Year-1/CCICOMP/Software-development-tools-and-acquisition"],"tags":["ccicomp"],"content":"Development tools §\nDevelopment tools are specialized software designed for creating software programs. These tools serve essential functions, including providing a conducive environment for programmers to write and manage their source code. Additionally, they play a crucial role in converting source code into machine-executable instructions.\n\nTranslators §\nTo execute programs written in high-level source code, they must be converted into instructions that a CPU understands, commonly known as machine code or object code, using a translator. The types of translators include:\n\nThere are three types of translators;\n\nCompilers\nAssemblers\nInterpreters\n\n\n\nCompilers §\n\nCompilers translate high-level code into intermediate assembly code or directly into machine code to produce an executable file before a program is run.\n\nAssemblers §\n\nAssemblers translate assembly code into machine code to produce an executable file before a program is run. Utilizing an assembler results in the generation of an executable file from the code.\n\nInterpreters §\n\nInterpreters translate high level code one line at a time into machine code as the program is being run.\n\nIntegrated devlopment environments §\nAn integrated development environment (IDE) furnishes programmers with a collection of software development tools, encompassing a source code editor, program build automation tools, debuggers, and code version control. Examples include DevC++, Eclipse, NetBeans, and VSCode.\n\nAcquiring software §\nSoftware licenses §\nUsing software necessitates obtaining its license and adhering to its end-user license agreement (EULA). When acquiring software, the payment involved is essentially for the license granting the right to use it.\n\nTypes of licenses §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProprietaryShareware/FreewareOpen Source (“Copyleft”)Public DomainCopyright retained by publisherYesYesYesNoCan acquire copy of codeNoNoYesYesCan modify the softwareNoNoYesYesCan freely copyNoUsually yesYesYesCan freely distributeNoUsually yesUnder same licenseYes\n\nSoftware installation §\nMost software executables require installation before they can run on a computer. Installing involves checking for system compatibility, unpacking software components, copying these components into appropriate folders, and storing user and computer settings needed to run the software correctly.\nWhen installing software, a user is often given the option for the following:\n\nFull installation (a.k.a. typical installation), which copies all commonly used files and programs from the distribution package to your computer and uses the default settings of the software.\nCustom installation, which allows a user to select only which components to install and to customize software settings.\n\n\nWeb software §\nWeb-based applications are those that are hosted online by the vendor and are commonly accessible through a browser without requiring separate installation. Examples include Google Docs, Canvas, and Dropbox. This distribution model is also called Software as a Service (SaaS). Web-based applications may be offered free-of-charge or through a subscription-based payment scheme. The key advantage of SaaS is accessibility and compatibility across a wide range of hardware platforms.\n\nSoftware piracy §\nSoftware piracy refers to unauthorized copying, distribution, and use of software. What constitutes piracy includes distributing copies of proprietary software to others, ’cracking’ software that would have otherwise been protected from illegal use, and using more copies of legitimately acquired software than what its End User License Agreement (EULA) permits.\n\nConsequences of software piracy §\nExposure to viruses, corrupt disk, or defective software, inadequate or no product documentation, no warranties, lack of technical support, and ineligibility for software upgrades offered for licensed users are potential risks associated with software piracy.\nLegal fines for software piracy may include violation of the IP Code of the Philippines RA 8293 and violation of the Optical Media Act RA 9239.\nPiracy is an ethical issue that leads to loss of income and jobs for the software industry and higher costs that legitimate users need to bear\n"},"Term-1-Year-1/CCICOMP/System-software":{"title":"System software","links":["Term-1-Year-1/CCICOMP/System-software"],"tags":["ccicomp"],"content":"Operating Systems §\nThe operating system (OS) is the most important software component installed on any computer system. It performs low-level tasks on behalf of users and application programs, manages the computer’s hardware, including the processor, memory, and storage devices, as well as peripheral devices such as the printer. Additionally, it provides a consistent means for application software to work with the central processing unit (CPU) and is responsible for the management, scheduling, and coordination of tasks.\n\nOperating System Layers §\nAn OS is organized internally into layers, making it easier to maintain because functions in one layer can be modified without affecting other layers. The outermost layers provide services to application programs or directly to end users, while the innermost layer encapsulates hardware resources for controlling and managing access.\n\nCommand layer §\nThe Command Layer serves as the user interface to the OS, enabling users to run applications and manage system resources.\n\nServices layer §\nThe Services Layer consists of reusable components that offer fundamental operations (e.g., file and folder manipulation, I/O access, starting and stopping programs) accessible through service calls.\n\nKernel §\nThe Kernel is responsible for managing resources and directly interacting with computer hardware.\n\nBoot Up Process §\nThe boot-up process is divided into four steps:\n\nActivating BIOS\nPerforming the POST\nLoading the OS\nApplying further configurations and customizations\n\n\nStep 1: Activating BIOS §\nThe CPU activates the basic input/output system (BIOS), a small program stored in ROM on the motherboard that manages the exchange of data between the OS and all the input and output devices attached.\n\nStep 2: Performing the POST §\nBIOS performs the power-on self-test (POST) to ensure that essential peripheral devices are attached and operational.\n\nStep 3: Loading the OS §\nBIOS goes through a preconfigured list of devices to search for the drive that contains the main files of the OS (system files). The kernel of the booted OS is loaded into RAM, and the OS takes over control of the system. In systems that have more than one OS installed (e.g., dual boot), the BIOS follows its boot priority to determine which OS to load into RAM.\n\nStep 4: Applying Further Configurations and Customizations §\nOnce booted, the OS loads any software settings and user configurations.\n\nOS Functions §\nUser Interface §\nThe user interface (UI) provides a means through which a user can run applications and utility programs, and manage system resources. The UI can be implemented as:\n\nA graphical user interface (GUI) allows interaction using menus and visual images.\nA command-line interface (CLI) accepts user input using commands represented by short keywords or abbreviations.\n\n\nMemory Management §\nMemory management optimizes the use of the computer or device’s internal memory. Only portions of a program that must be in RAM during execution are the next instruction to be fetched and any data it is using. Most OS minimize the amount of code and data stored in RAM at one time to allow remaining space in memory to be used by other programs. Virtual memory, a portion of secondary storage functioning as additional RAM, is employed. Virtual memory management involves dividing a program into fixed-size portions called pages and using a reserved area in secondary storage, called the page file or swap space, to temporarily hold program pages not in use during execution. The OS regularly moves program pages between RAM and the page file as needed.\n\nTask Coordination §\nThe operating system’s handling of programs directly affects productivity. This can involve single-tasking (running one program at a time) or multitasking (running multiple programs simultaneously) in both foreground (with user interaction) and background (without user interaction) modes, with single user or multiuser support. The OS determines the order in which tasks are processed, and a multitasking OS allows multiple programs to share computer resources within a timeframe. Programs and devices use interrupts to signal to the OS their resource requirements. The OS scheduler makes rapid decisions to determine which program receives resource control and for how long, based on priority. The ability to quickly switch between tasks and allow them to appear simultaneous gives an OS its multitasking capability.\n\nDevice Configuration §\nA device driver is a special program that allows the OS to control a device by translating the device’s specialized commands into commands the OS can understand, and vice versa. Plug and Play (PnP) automatically configures new devices as you install or connect them. Non-PnP devices require manual installation of their drivers by the user.\n\nTypes of Operating Systems §\nThere are different categories of operating systems depending on the type of computer system they are used on and the kind of usage they are suited for.\n\nDesktop OS §\nA desktop operating system serves a single user at a time and operates on personal devices like laptops and desktop computers. By default, it runs with a graphical user interface (GUI), providing a visual environment for user interaction. The system also includes user application software, such as browsers, games, and productivity software.\n\nExamples include Windows, macOS, and Linux\n\n\nServer OS §\nA server operating system exhibits several characteristics. It serves multiple users simultaneously and is designed to run on servers and mainframes. The system includes software that delivers services, commonly through a network, encompassing functions such as web hosting and file hosting. Typically, a dedicated system administrator manages server operating systems.\n\nExamples include Windows Server, macOS Server, UNIX, and Linux\n\n\nMobile OS §\nA mobile operating system possesses specific characteristics tailored for mobile devices and consumer electronics. It is crafted to be power-saving, prioritizing efficiency for portable devices. Furthermore, the user interface design is optimized for touch screens, enhancing the overall user experience on mobile platforms.\n\nExamples include Google Android, Apple iOS, and Windows (Mobile Edition)\n\n\nReal-time OS §\nContiki OS, VxWorks, Embedded Systems\n"},"Term-1-Year-1/CCICOMP/System-unit-components":{"title":"System unit components","links":[],"tags":["ccicomp"],"content":"System unit §\nThe system unit or chassis refers to the case that contains and protects the motherboard, hard disk drive, memory, and other hardware components.\n\nMotherboard §\nThe motherboard, sometimes called a system board, is the main circuit board of the computer. Many electronic components, such as the processor and memory, are attached to the motherboard; others are built into it.\n\nCentral processing unit §\nThe central processing unit (CPU), also called a processor, is sometimes called the brain of the computer. It is usually a silicon chip about the size of a thumbnail. It fits into the motherboard’s CPU socket, which is covered by the heatsink that absorbs heat from the CPU and fan to dissipate the heat.\n\nChipset §\nThe chipset controls the communication between the CPU, memory, storage, and other peripherals (e.g. keyboard, mouse, or monitor). The chipset determines how many high-speed components or devices the motherboard can support.\n\nRandom access memory (RAM) §\nThe random access memory (RAM), also called the main memory, temporarily stores data whenever the computer performs operations. Contents of the memory disappears when the computer is turned off.\n\nHard disk drive §\nThe hard disk drive, is a long-term storage that holds data even when the computer is turned off. In some computers, specially laptops, a solid-state drive is used.\n\nPower supply §\nThe power supply unit, or laptop AC adapter, converts electricity from the outlet (AC 1 20 or 220 volts) to a type of power (DC 5 to 15 volts) that the computer can use. Different motherboards and computers require different wattages on the power supply. In desktop computers, power supply has built-in fans that keeps the power supply cool.\n\nExpansion slots §\nMost motherboards have built-in video, sound, and network capabilities. However, in certain cases, the user might want to improve the performance and capabilities of a computer. In such cases, motherboards have expansion slots that allows users to add various types of expansion cards or adapter cards.\n\nBluetooth adapter §\nEnables Bluetooth connectivity\n\nMIDl §\nConnects to musical instruments\n\nModem §\nConnects to transmission media, e.g., television or phone lines\n\nNetwork §\nProvides network connections, such as an Ethernet port\n\nSound §\nConnects to speakers or microphone\n\nUSB §\nConnects to high speed USB ports\n\nVideo §\nUsually have a GPU (graphics processing unit) to enhance computer graphics capabilities such as\naccelerated processing or to connect to an additional monitor\n\nPeripheral Component Interconnect (PCI) §\nThe Peripheral Component Interconnect, or PCI, is the input/output pathway that connects the CPU, via the expansion slots, to the peripheral devices.\n\nSerial Advanced Technology Attachment (SATA) §\nThe Serial Advanced Technology Attachment, or SATA, is a computer bus interface used to connect drive disk controllers or host bus adapters with mass storage devices like optical drives and hard disk drives.\n\nComplementary Metal Oxide Semiconductor (CMOS) Battery §\nThe Complementary Metal Oxide Semiconductor, also known as CMOS battery, is responsible for keeping all the information intact when the entire system is shut down. This prevents reconfiguration when the PC is powered off.\n\nProcessor and Multicore Technology §\nThe processor interprets and carries out basic instructions that operate a computer. On large computer systems, such as mainframes and supercomputers, the various functions performed by the processor extend over many separate chips and multiple circuit boards. On a personal computer system, all functions of the processor usually are on a single chip, called a microprocessor.\n\nProcessor Core §\nA processor core contains the circuitry necessary to execute instructions. The operating system views each processor core as a separate processor.\n\nMulticore Processor §\nA multicore processor is a single chip with two or more processor cores.\n\nControl Unit §\nThe control unit is the component of the processor that directs and coordinates most of the operations in the computer. It interprets each instruction issued by a program and then initiates the appropriate action to carry out the instruction.\n\nArithmetic Logic Unit (ALU) §\nThe Arithmetic Logic Unit (ALU) is the component of the processor that performs arithmetic and logic operations. Arithmetic operations include addition, subtraction, multiplication, and division. Logic operations encompass comparison operations like greater than, less than, or equal to.\n"},"Term-1-Year-1/CCPROG1/(Q&A)-Functions-and-programs":{"title":"(Q&A) Functions and programs","links":["Term-1-Year-1/CCPROG1/Functions-and-programs","Term-1-Year-1/CCPROG1/Problem-analysis,-logic-formulation-and-flowcharting","Term-1-Year-1/CCPROG1/Tokens-and-token-classification"],"tags":["ccprog1"],"content":"See also: Functions and programs\nWhat is a statement? §\nAll C programs are made up of a sequence of instructions. In C, instructions are also called statements. In the English language, a statement is terminated by a period, a question mark, or an exclamation point. In C, a statement is terminated by a semicolon.\n\nWhat is the use of {} symbols? §\nThe symbols { and } are called an open and close brace, respectively. They signify the start and the end of a block. Note that the braces always come in pairs.\n\nWhat is the use of /* */ symbols? §\nThese symbols group comments inside the program. Comments are not instructions, rather they simply provide additional information (a textual description) such as what the program is doing, what are the inputs and outputs, etc. Comments are optional and may be placed anywhere within the program source code.\n"},"Term-1-Year-1/CCPROG1/(Q&A)-Tokens-and-token-classification":{"title":"(Q&A) Tokens and token classification","links":["Term-1-Year-1/CCPROG1/Tokens-and-token-classification","Term-1-Year-1/CCICOMP/Data-representation","Term-1-Year-1/CCPROG1/Problem-analysis,-logic-formulation-and-flowcharting","Term-1-Year-1/CCPROG1/Float-and-integer-operations"],"tags":["ccprog1"],"content":"See also: Tokens and token classification\nWhat is a variable? §\nA variable is an entity that is used to store data. It is the name that the programmer uses to indicate what space in the memory he wants to access. For this space to be accessed, it should be reserved first. Reserving a memory space and giving it a name is called a variable declaration. The type of data (data type) to be stored in the memory will indicate how much space is going to be reserved. Each variable has a name, an associated physical memory space (in RAM), a data type, a value, a scope, and a lifetime.\n\nWhat is a data type? §\nA data type specifies information regarding how data is stored in a variable.\n\nCan I use any name for the variables? §\nYes, as long as you follow the naming conventions, and do not use the reserved words in C. It is recommended, however, as a good programming practice, for you to use a name that is descriptive or suggestive, and follow some coding standards.\n\nWhat is the value of the variable initially? §\nBy default, the value of a variable is garbage, i.e., there is something stored in that memory space but that something unknown. Using variables with garbage values will cause logical errors.\n\nWhat will happen if I assigned a value whose data type is different from the data type of the receiving variable? §\nThe value will be converted. In general, one that requires smaller memory will fit into the variable with a larger space. The opposite will result to loss of information (which could cause a logical error). The basic rules of data type conversion are as follows:\n\nint to float/double: value will be converted to a floating-point value\nfloat/double to int: the fractional part is dropped or truncated\nchar to int/float/double: the char value (based on ASCII character set) will be converted automatically to int/float/double with no problem\nint to char: if the int value is within the possible range of char values (0 – 255) then that value is assigned and converted to the ASCII character equivalent; otherwise, the value assigned could be unpredictable\nfloat/double to char: the fractional part will be discarded and with the whole number part, the same rule as int to char will be applied\n\n"},"Term-1-Year-1/CCPROG1/Conditional-statements":{"title":"Conditional statements","links":["Term-1-Year-1/CCICOMP/Data-representation","Term-1-Year-1/CCICOMP/Character-representation"],"tags":["ccprog1"],"content":"The if statement §\nThe if statement allows a program to choose between two alternatives by testing the value of an expression. In its simplest form, the if statement has the form:\nif (expression)\n\tstatement\nThe statement is executed when the condition specified by expression has a nonzero value, which is interpreted as true:\nif (x == 10)\n\tprintf(&quot;x is equal to %d&quot;, x);\nThe above code will execute printf() if the [[Operator types, precedence, and associativity#Equality operators||equality operation]] x == 10 evaluates to a nonzero value; in this case, the expression will evaluate to 1 if x has a value of 10 and 0 otherwise. In other words, the printf() will execute if x has a value of 10.\nFurthermore, multiple statements may be executed following an if if wrapped in braces ({}), like so:\nif (x == 10) {\n\tx++;\n\tprintf(&quot;x + 1 is equal to %d&quot;, x);\n}\n\nThe else clause §\nAn if statement may have an else clause:\nif (expression)\n\tstatement\nelse\n\tstatement\nThe statement that follows else will be executed if the expression in if has a value of 0:\nif (i &gt; j)\n\tmax = i;\nelse\n\tmax = j;\nelse statements belong to the nearest if statement that has not yet been paired with an else. Thus, to avoid ambiguity, statements such as:\nif (y != 0)\n\tif (x != 0)\n\t\tresult = x / y;\nelse\n\tprintf(&quot;Error: y is equal to 0\\n&quot;);\n—which would result in the else being a part of if (x != 0) rather than if (y != 0) as the indentation would suggest, the statements may be wrapped around braces:\nif (y != 0) {\n\tif (x != 0)\n\t\tresult = x / y;\n} else\n\tprintf(&quot;Error: y is equal to 0\\n&quot;);\n\nThe switch statement §\nA switch statement of the form:\nswitch (expression) {\n\tcase constant_expression:\n\t\tstatements\n\tcase constant_expression:\n\t\tstatements\n\t\t...\n\tcase constant_expression:\n\t\tstatements\n\tdefault:\n\t\tstatements\n}\nexpression must be an integer (or character, which is treated by C as an integer) expression. Floating-point numbers and strings cannot be used with switch.\nconstant_expression are expressions that cannot contain variables or function calls. After each case label, one can put any number of statements that do not need to be wrapped in braces. Furthermore, several case labels may precede the same set of statements:\nswitch (grade) {\n\tcase 4: case 3: case 2: case 1:\n\t\tprintf(&quot;Passing&quot;);\n\t\tbreak;\n\tcase 0:\n\t\tprintf(&quot;Failing&quot;);\n\t\tbreak;\n\tdefault: \n\t\tprintf(&quot;Illegal grade&quot;);\n\t\tbreak;\n} \nThe break statement causes the program to “break” out of the switch statement and pass control to the next statement after switch. Without break, control instead passes from the successful case and into every proceeding case:\nswitch (grade) {\n\tcase 4: printf(&quot;Excellent&quot;);\n\tcase 3: printf(&quot;Good&quot;);\n\tcase 2: printf(&quot;Average&quot;);\n\tcase 1: printf(&quot;Poor&quot;);\n\tcase 0: printf(&quot;Failing&quot;);\n\tdefault: printf(&quot;Illegal grade&quot;);\n}\nThe above code, given a value of 3 for grade, will output:\nGoodAveragePoorFailingIllegal grade\n\nThis is known as falling through.\n\nDuplicate case labels are not allowed. The order of the labels do not matter, and the default case (which is executed when no match is found), does not need to be last.\n\n"},"Term-1-Year-1/CCPROG1/Float-and-integer-operations":{"title":"Float and integer operations","links":["Term-1-Year-1/CCPROG1/Tokens-and-token-classification"],"tags":["ccprog1"],"content":"See also: Tokens and token classification\nOperator: + (addition) §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRuleExampleint + int = int5 + 2 = 7int + float = float5 + 2.0 = 7.0float+ int = float5.0 + 2 = 7.0float+ float = float5.0 + 2.0 = 7.0\n\nOperator: - (subtraction) §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRuleExampleint - int = int5 - 2 = 3int - float = float5 - 2.0 = 3.0float - int = float5.0 - 2 = 3.0float - float = float5.0 - 2.0 = 3.0\n\nOperator: * (multiplication) §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRuleExampleint * int = int5 * 2 = 10int * float = float5 * 2.0 = 10.0float * int = float5.0 * 2 = 10.0float * float = float5.0 * 2.0 = 10.0\n\nOperator: / (division) §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRuleExampleint / int = int5 / 2 = 2int / float = float5 / 2.0 = 2.5float / int = float5.0 / 2 = 2.5float / float = float5.0 / 2.0 = 2.5\n"},"Term-1-Year-1/CCPROG1/Formatted-input-and-output":{"title":"Formatted input and output","links":["Term-1-Year-1/CCPROG1/Tokens-and-token-classification","Term-1-Year-1/CCPROG1/Formatted-input-and-output"],"tags":["ccprog1"],"content":"Conversion specifications §\nA conversion specification is a placeholder beginning with % that represents a value to be filled in during printing. The information that follows the % character specifies how the value is converted from its internal form (binary) to printed form (characters). Conversion specifications are usually of the form:\n%m.pX\n—where m and p are integers and X is a letter. Both m and p are optional; if p is omitted, the period that separates m and p is also dropped.\n\nConversion specifier X §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSpecifierMeaning%cFor character type%dFor signed integer type%e or %EFor scientific notation of floats%fFor float type%g or %GFor float type with fixed decimal or scientific notation, depending on size%iUnsigned integer%ld or %liLong%lfDouble%LfLong double%luUnsigned int or unsigned long%lli or %lldLong long%lluUnsigned long long%oOctal representation%pPointer%sString%uUnsigned int%x or %XHexadecimal representation%nPrints nothing%%Prints % character \n\n\n\n\nThe conversion specifier indicates which conversion should be applied to the value before it is printed.\n\nMinimum field width m §\nThe minimum field width m in the format %m.pX specifies the minimum number of characters to print. If the value to be printed requires fewer than m characters, the value is right-justified within the field (i.e., spaces are added preceding the value):\nint x = 10\nprintf(&quot;%4d&quot;, x);\n—will output the following:\n  10\n\nAdding a 0 will indicate that zeroes will be added instead of spaces:\nint x = 10\nprintf(&quot;%04d&quot;, x);\n—will output the following:\n0010\n\n\nIf m is negative, the output string will be left-justified within the field instead (i.e., spaces are added after the value).\n\n\nPrecision p §\nThe behavior of p in the format %m.pX depends on the value of X. For d (decimal integers), p indicates the minimum number of digits to display (with leading zeros added if necessary). In this case, p is assumed to have a value of 1 by default.\nprintf(&quot;%.4d&quot;, 123); // Outputs 0123\nFor e (scientific notation floating-point), and f (fixed decimal floating-point), p indicates how many digits should appear after the decimal point. This is assumed to be 6 by default; if it is 0, the decimal point is not displayed. This rounds off rather than truncates.\nprintf(&quot;%.1e\\n&quot;, 339.10130); // Outputs 3.4e+02\nprintf(&quot;%.2f&quot;, 339.10130); // Outputs 339.10\nFor g (fixed decimal or scientific notation, depending on size), p indicates the maximum number of significant digits to be displayed. Unlike f, g will not display trailing zeros; if the value to be printed has no digits after the decimal point, g will not display the decimal point.\nprintf(&quot;%.1g\\n&quot;, 339.10130); // Outputs 3e+02 (Does not display decimal point)\nprintf(&quot;%.5g&quot;, 339.10130); // 339.1 (Does not display trailing zeros)\n\nThe printf() function §\nThe printf function is designed to display the contents of a string, known as the format string, with values possibly inserted at specified points in the string:\nprintf(string, expr1, expr2, ...);\nThe values to be printed can be constants, variables, or other expressions; there are no limits to how many can be printed by a single printf() call.\n\nFormat string §\nThe format string string may contain ordinary characters or conversion specifications. Ordinary characters in a format string are printed exactly as they appear in the string while conversion specifications are replaced by the values to be printed:\nint i, j;\nfloat x, y;\ni = 10;\nj = 20;\nx = 43.2892;\ny = 5527.0;\nprintf(&quot;i = %d, j = %d, x = %f, y = %f\\n&quot;, i, j, x, y);\nThe above code produces the following output:\ni = 10, j = 20, x = 43.289200, y = 5527.000000\n\nThe %d and %f specifiers are replaced with the values of i, j, x, and y.\n\nThe scanf() function §\nscanf() reads input according to a particular format; it is a “pattern-matching” function that tries to match up groups of input characters with conversion specifications. When called, it begins processing the information in the provided format string, starting from the left. For each conversion specification it encounters in the string, it will try to locate an item of the appropriate type in the input stream (to which the user input via keyboard is “pushed” or stored), skipping whitespaces as necessary. It then reads the item, stopping when it encounters a character that cannot possibly belong to the item (as defined by the conversion specification) after which the statement stops, passing control to the next statement. This means all succeeding specifiers will be ignored:\nint x;\nchar y = &#039;#&#039;, z;\nscanf(&quot;%d %c&quot;, &amp;x, &amp;y);\nscanf(&quot;%c&quot;, &amp;z);\nprintf(&quot;\\n\\n%d, %c (%c was left in stream after the first scanf)&quot;, x, y, z);\nreturn 0;\nGiven the input 2!?, the above code produces the following output:\n2, ! (? was left in stream after the first scanf)\n\nInputting !?* instead gives the following output, showing that the first scanf() ignored y and %c after it failed to match %d:\n0, # (! was left in stream after the first scanf)\n\n"},"Term-1-Year-1/CCPROG1/Functions-and-programs":{"title":"Functions and programs","links":["Term-1-Year-1/CCPROG1/(Q&A)-Functions-and-programs"],"tags":["ccprog1"],"content":"\nSee also: FAQ\nC programs are usually made up of different functions.\nFunctions §\nA function is a group of instructions in C that performs a particular task, or as the name implies, performs a specific function. As such, functions are also called subprograms. All C programs have to have at least one function, the main() function. This is the primary function in any C program and its statements are executed first.\nFunctions in C are similar to functions in mathematics, for example, consider the function f(x):\nf(x)=x2+1\nthat implies that given the value of x we can compute or evaluate using the formula to get the value of f(x). For example in this case, if x were 3 then f(x) would be 10. In a way, x is our input, and f(x) yields some output. Note however for C functions there are cases when it does not evaluate to any value and is merely a collection of instructions. This is in some programming languages called a procedure.\n\nLibraries §\nA library in C is a collection of different functions. The C standard libraries already provide numerous built-in or predefined functions that we can use in our programs. Alternatively, we can also create our own functions or user-defined functions and even create our own library. In this chapter, we look into how to write the main() function, use pre-defined functions, and create our own functions.\n\nC program structure §\nThe basic structure of a simple C program is as follows:\n\nPreprocessor directives\nFunction definitions\nMain function\n\n\nPreprocessor directives §\nPreprocessor directives are commands that are done before compiling the program. They usually involve changing the source file before handing it over to the compiler. Common preprocessor directives are #include that is used to include header files and use libraries. Defining constants using #define is also one example of preprocessor directives.\n\nFunction definitions §\nFunctions definitions are the code of the functions written by the programmer. The main function is the main block of code in our program.\n\nMain function §\nThe main function is the main section or the main block of the entire program. It is the first part of the program to be executed. The other sections are optional but a C program must have one and only one main() to run.\nThe open brace ({) signifies the start of the program, while the (}) signifies the end of the program. Within the braces, variable declarations should be made. The statements enclosed within the braces are the instructions that form part of the main() function. The int beside main() is the return type of the function, in this case, the main returns an integer. The last line, return 0; transfers the control from your program back to your operating system. It returns the value zero (0) which means there were no errors and the program terminated correctly. In this example, we have a program that computes the area of a rectangle with the base having 10.5 units and the height with 5.0 units. Note that nothing will be shown on the screen since we have not used any input/output statements yet.\nint main()\n{\n\t/* variable declaration */\n\tfloat fBase, fHeight;\n\tfloat fArea;\n\t\n\t/* statements */\n\tfBase = 10.5;\n\tfHeight = 5.0;\n\tfArea = fBase * fHeight;\n\treturn 0;\n}\n"},"Term-1-Year-1/CCPROG1/Iterative-statements":{"title":"Iterative statements","links":["Term-1-Year-1/CCPROG1/Iterative-statements"],"tags":["ccprog1"],"content":"Loops §\nLoops are statements  whose job is to repeatedly execute some other statement (the loop body). In C, every loop has a controlling expression. Each time the loop body is executed (an iteration of the loop), the controlling expression is evaluated; if the expression is true—has a value that’s not zero— the loop continues to execute.\n\nC provides 3 iterative statements: while, do, and for.\n\n\nThe while statement §\n\nOf all the ways to set up loops in C, the while statement is the simplest and most fundamental. The while statement has the form\nwhile (expression)\n\tstatement\nWhen a while statement is executed, the controlling expression is evaluated first. If its value is nonzero (true), the loop body is executed and the expression is tested again. The process continues in this fashion—first testing the controlling expression, then executing the loop body—until the controlling expression eventually has the value zero. The following example uses a while statement to compute the smallest power of 2 that is greater than or equal to a number n, in this case 3:\nn = 3;\ni = 1;\nwhile (i &lt; n)\n\ti = i * 2;\n\nThe following trace shows what happens when the while statement is executed:\nn = 3; — n is now equal to 3\ni = 1; — i is now equal to 1\nIs i &lt; n? — Yes; continue\ni = i * 2 — i is now equal to 2\nIs i &lt; n? — Yes; continue\ni = i * 2 — i is now equal to 4\nIs i &lt; n? — No; exit from the loop\n\n\nInfinite loops §\nA while statement won’t terminate if the controlling expression always has a nonzero value.\nwhile (1) ...\nA while statement of this form will execute forever unless its body contains a statement that transfers control out of the loop or calls a function that causes the program to terminate.\n\nThe do statement §\n\nThe do statement is essentially a while statement whose controlling expression is tested after each execution of the loop body. It has the form:\ndo statement while (expression);\nThe following example prints down from 10 to 1:\ni = 10;\ndo {\n\tprintf(&quot;T minus %d and counting\\n&quot;, i);\n\t--i;\n} while (i &gt; 0);\nThe loop body is first executed, after which the condition is tested (as opposed to while loops, which test a condition before executing the body). This means that the body of a do statement is always executed at least once; the body of a while statement is skipped entirely if the controlling expression is 0 initially.\n\nThe for statement §\n\nThe for statement is ideal for loops that have a “counting” variable and has the following form:\n  // initialization; condition;   update\nfor (expression1;    expression2; expression3)\n\tstatement\nIn the following example:\nfor (i = 10; i &gt; 0; i--)\n\tprintf(&quot;T minus %d and counting\\n&quot;, i);\nThe variable i is first initialized to 10; it is then tested against the condition i &gt; 0. If the condition is true, the loop body is executed, then the update of decrementing i is performed.\n\n"},"Term-1-Year-1/CCPROG1/Operator-types,-precedence,-and-associativity":{"title":"Operator types, precedence, and associativity","links":["Term-1-Year-1/CCPROG1/Tokens-and-token-classification","Term-1-Year-1/CCPROG1/Float-and-integer-operations"],"tags":["ccprog1"],"content":"See also: Tokens and token classification\nArithmetic operators §\nC has arithmetic operators that perform basic arithmetic operations. Binary operators require two operands. Unary operators require one. All binary operators accept integer or floating-point operands (with the exception of %, which only takes integers); if at least one operand is a float, then so will be the result. Otherwise, the fractional part is truncated and the result is stored as an int. Note that the use of 0 as the right operand with / or % results in undefined behavior.\n\nIn C99, if either operand in a division operation is negative, the result is truncated towards 0 (visually this appears as if the fractional part is simply deleted, i.e. -9 / 7 results in -1 rather than -2). On the other hand, the result of a modulo operation will take the sign of the left operand (hence 9 % 7 results in -2). This is because (a/b) * b + a%b should be a.\n\n\nUnary operators\n\n+ Unary plus\n- Unary minus\n\n\nBinary operators\n\nAdditive\n\n+ Addition\n- Subtraction\n\n\nMultiplicative\n\n* Multiplication\n/ Division\n% Remainder (modulo)\n\n\n\n\n\n\nRelational operators §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSymbolMeaning&lt;Less than&gt;Greater than&lt;=Less than or equal to&gt;=Greater than or equal to\n\n\n\n\nRelational operators in C correspond to the &lt;, &gt;, ≤, and ≥ operators in mathematics, evaluating to 0 if the expression is false or 1 if it is true. For instance, 10 &lt; 11 evaluates to 1, while 11 &lt; 10 evaluates to 0. These operators accept two integers or floating-point numbers as operands (it is thus a binary operator) and associate from left to right; i.e., the expression:\ni &lt; j &lt; k\n—evaluates to:\n(i &lt; j) &lt; k\n—where i &lt; j can be 1 or 0.\n\nEquality operators §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSymbolMeaning==Equal to!=Not equal to\n\n\n\n\nEquality operators, similar to &lt;, &gt;, &lt;=, and &gt;=, evaluate to 0 (false) or 1 (true) and associate from left to right. However, these operators have lower precedence; i.e., the expression:\ni &lt; j == j &lt; k\n—evaluates to:\n(i &lt; j) == (j &lt; k)\n\nLogical operators §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSymbolMeaningNumber of operands!Logical NOTUnary&amp;&amp;Logical ANDBinary||Logical ORBinary\n\n\n\n\nLike relational operators, logical operators produce 0 (false) or 1 (true) as a result. Additionally, however, their operands will be taken as false only if they have a value of 0. Non-zero values are taken as true. As such:\n\n!x will evaluate to 1 if and only if x has a value of 0; otherwise, it will evaluate to 0.\nx &amp;&amp; y will evaluate to 1 if and only if x and y both have non-zero values; otherwise, it will evaluate to 0.\nx || y will evaluate to 1 if and only if either x or y has a non-zero value; otherwise, it will evaluate to 0.\n\n\n\n&amp;&amp; and || perform short-circuit evaluations of their operands. That is, these operators first evaluate the left operand, then the right operand. If the value of the expression can be deduced from the value of the left operand alone, then the right operand is not evaluated (i.e. it is ignored).\n\n\nAssignment operators §\nThe assignment operator = evaluates to the value of the right operand while storing (copying) this value to its left operand (this is known as a side effect). As such, it requires its left operand to be an lvalue, i.e., an object with an accessible memory address, such as a variable. For instance, the following:\nx = 2;\n—is evaluated to (results in) 2 while updating the variable x to have the value 2. The right operand in an assignment operation can be a constant, a variable, or a more complicated expression. As such, statements such as:\nx = y = 2;\n—result in y = 2 being evaluated to 2which is then stored into x (the = operator associates from right to left). In other words, both x and y will now have the value 2.\n\nEmbedded assignments impact code readability and are discouraged.\n\n\nCompound assignment §\nC provides “shortcut” assignment operators aside from = for using a variable’s old value to compute its new value. These include +=, -=, *=, /=, and %=. For example, the statements:\ni = i + 2;\n—and:\ni += 2;\n—result in the same effect. Similarly to =, this operation evaluates to the new value of the variable (in this case i + 2) and has the side effect of updating the value of said variable.\n\nIncrement and decrement §\nThe statements:\ni = i + 1;\n—and:\ni += 1;\n—get the value of i, add it with 1, and stores it again to i. As a result, if the initial value of i is 5, after executing this statement, it will have the value of 6. To simplify the increment statement, C allows us to use the increment and decrement operators. The increment operator ++ and the decrement operator -- both take a single variable (whether integer or floating-point) as its operand:\ni++;\nFurthermore, both ++ and -- can be used as either prefix (e.g. ++i) or postfix (e.g. i++) operators. The difference lies in evaluating them as operations: ++i evaluates to the new value of i after the increment (“post-increment”), while i++ evaluates to the old value (“pre-increment”). In both cases, the variable i is incremented by 1 as a side effect.\n\nThe C standard does not specify an exact time for when the postfix ++ and -- operators increment their operand—only that it is before the next statement is executed. This results in undefined behavior (i.e. unpredictable results) when performing operations such as ++i + i++ where i is modified and used in the same statement.\n\n\nOperator precedence and associativity §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPrecedenceNameSymbol(s)Associativity1Array subscripting[]Left1Function call()Left1Structure and union member. -&gt;Left1Increment (postfix)++ --Left1Decrement (postfix)++ --Left2Increment (prefix)++ --Left2Decrement (prefix)++ --Left2Address&amp;Right2Indirection*Right2Unary plus+Right2Unary minus-Right2Bitwise complement~Right2Logical negation!Right2SizesizeofRight3Cast()Right4Multiplicative* / %Left5Additive+ -Left6Bitwise shift&lt;&lt; &gt;&gt;Left7Relational&lt; &gt; &lt;= &gt;=Left8Equality== !=Left9Bitwise and&amp;Left10Bitwise exclusive or^Left11Bitwise inclusive or|Left12Logical and&amp;&amp;Left13Logical or||Left14Conditional?:Right15Assignment= *= /= %= += -= &lt;&lt;= &gt;&gt;= &amp;= ^= |=Right16Comma,Left \n\n\n\n\nEvaluation of operators should follow a hierarchy of priorities. Evaluate expressions with higher priority operators first. Consider the expression a ~ b ~ c. If the operator ~ has left associativity, this expression would be interpreted as (a ~ b) ~ c. If the operator has right associativity, the expression would be interpreted as a ~ (b ~ c).\n\nIt can be easier to simplify the order of precedence as:\n\nPostfix unary operators\nPrefix unary operators (right to left)\nParentheses (cast)\nMultiplication/division/modulo\nAddition/subtraction\nRelational operators\nEquality\nAND\nOR\nAssignment\n\n\n"},"Term-1-Year-1/CCPROG1/Pointers-and-pointer-variables":{"title":"Pointers and pointer variables","links":["Term-1-Year-1/CCICOMP/Data-representation","Term-1-Year-1/CCPROG1/Problem-analysis,-logic-formulation-and-flowcharting"],"tags":["ccprog1"],"content":"\nPointer variables §\nHolds a memory address where a value may be stored.\nWritten as a data type followed by an *, i.e.\nfloat* pVal; // Pointer \n\n\nReferencing §\nReferencing is taking the address of an existing variable using the reference operator &amp;. In the example:\nint  dVal;\nint* pVal;\npVal = &amp;dVal;\npVal references dVal, i.e., takes its address and sets it as its value.\n\nDereferencing §\nDereferencing is retrieving the value from a memory address that is pointed to by a pointer using the dereference operator *. In the example:\nint* pVal;\nint  dVal;\ndVal = *pVal;\ndVal dereferences pVal, i.e., retrieves the value from the memory address it points to.\nThe value stored at the address of the pointer must be a value of the same type as the type of variable the pointer “points” to.\n\nErrors and crashes §\nInvalid dereferencing §\n\nDereferencing an uninitialized pointer can cause a crash.\nDereferencing with an invalid type cast will have the potential to cause a crash.\nDereferencing a pointer to a variable that was dynamically allocated and was subsequently de-allocated can cause a crash\nDereferencing a pointer to a variable that has since gone out of scope can also cause a crash.\n\n\nInvalid referencing §\nInvalid Referencing is more likely to cause a compiler error than run-time crashes.\n"},"Term-1-Year-1/CCPROG1/Problem-analysis,-logic-formulation-and-flowcharting":{"title":"Problem analysis, logic formulation and flowcharting","links":["Term-1-Year-1/CCPROG1/Problem-analysis,-logic-formulation-and-flowcharting","Term-1-Year-1/CCPROG1/Tokens-and-token-classification"],"tags":["ccprog1"],"content":"\nProgramming §\nProgramming is the process and art of making a program. A program is a set of instructions that directs a computer. The program development life cycle is a set of steps or phases that are used to develop a program in any programming language. Generally, the program development life cycle contains 5 phases, which are as follows: 1. problem analysis; 2. algorithm or flowchart design; 3. implementation or coding; 4. running, testing, and debugging; and 5. documentation and maintenance. Figure 2.1 shows a diagram of a cyclical program development life cycle.\n\nProgram planning and development §\nProblem analysis §\nThe first step in program development is analyzing the problem. In general, computer programs try to solve a specific real-world problem. The initial task of a programmer is to identify and understand the problem. Since the computer is an input-output machine, one of the main tasks is identifying the input and output of the program, while considering all the information needed to solve the problem, and then coming up with the specific steps to transform the input into the desired output. During this phase, we also consider if there are any constraints or conditions present, and how they influence or affect the problem-solving process.\n\nAlgorithm design / Setting up algorithms to solve problems §\nAfter the problem has been clearly defined, a list or sequence of steps to solve the given problem must be formulated. This sequence of steps is called an algorithm.\nAn algorithm can be described in many ways. A natural language such as Filipino, English, or Chinese can be used but we must be very careful that the algorithm should be written in a logical and clear manner. Graphical forms or notations such as flowcharts can be used, an improvement of the former, but is more sophisticated. It is important to note that in whatsoever manner an algorithm is written, it still cannot be executed on a computer simply because it cannot be completely understood by the machine.\n\nCoding / Implementation §\nAfter having set up the algorithm, the next step is to convert this list of instructions into code, a language that the computer can understand and execute, and this process is called coding.\nOur code must be written in a specific programming language. This code can easily be converted by a compiler and assembler to machine code or machine language that a computer can understand. In our case, we will be utilizing the C programming language. This code or list of instructions written in a specific programming language is what we call a program.\n\nEncoding §\nInvolves entering code into a computer.\n\nRunning, testing, and debugging §\nCompilation §\nInvolves the conversion of source code to machine code. A successful compilation generates an executable file. This can be done through a terminal with gcc in Windows:\ngcc -Wall -std=c99 [source filename] -o [output filename]\n\n\nRunning §\nInvolves executing the compiled program.\n\nTesting §\nTesting is verifying that our program is correct and is free of any errors. It is the art of preparing different sets of sample input data that will be used on our program. It involves checking whether code matches and allows for the discovery of bugs through test sets and cases; bugs can stem from syntax or logical errors and may occur at compile-time or run-time.\n\nSyntactical errors §\nSyntactical errors result from failure to follow the syntax of the language. Syntax refers to the grammatical rules of the language defining its legal constructs. Examples of which are unrecognized instructions, missing punctuation marks, and misspelled names.\n\nLogical errors §\nLogical errors are hard to identify. What is erroneous here are the outputs seen onscreen which did not conform to or match the expected results. Such errors arise during the formulation of the algorithm or in the coding of the program that implements the algorithm due to the wrong analysis or perhaps wrong approach of the programmer as he tackles the problem given.\n\nCompile-time errors §\nCompile-time errors halt the compilation of the program. Program codes are translated completely so long as their syntax is correct. Once a syntax error is encountered during compilation, this is considered to be a compile-time error.\n\nRun-time errors §\nErrors that appear during the program’s execution are called run-time errors. Once a program starts running, it means that the program is already free of syntax errors and compilation has successfully finished. However, it may still have logical errors that may cause the abnormal termination of the program. An example would be dividing a certain number by zero. Another would be the program that is caught in an endless loop that cannot be stopped using the usual user input and has to be terminated through external means to end the process. Some endless loops can also cause resources, like the RAM, to be exhausted which would eventually lead to an abnormal termination of the program.\n\nDocumentation / Maintenance §\nInternal documentation via code comments can produce a technical manual for developers. Eventually, a user manual detailing how to use the program on the user’s end is created.\n\nUser’s manual §\nSoftware usually comes with a user’s manual and it contains information on the software and hardware requirements, installation procedures, and step-by-step instructions on how to use the system. This type of documentation is used by the user of the program.\n\nTechnical manual §\nThe technical manual is a printed copy of the information regarding how the program was designed and how it was created. Issues involved in choosing the data type or data structure, as well as the algorithm for the solution, are also included. On the other hand, the internal documentation has the same information but these are stored within the program themselves, through the use of comments.\n"},"Term-1-Year-1/CCPROG1/Tokens-and-token-classification":{"title":"Tokens and token classification","links":["Term-1-Year-1/CCPROG1/(Q&A)-Tokens-and-token-classification","Term-1-Year-1/CCPROG1/Tokens-and-token-classification","Term-1-Year-1/CCICOMP/Data-representation","Term-1-Year-1/CCPROG1/Functions-and-programs","Term-1-Year-1/CCICOMP/Floating-point-representation","Term-1-Year-1/CCPROG1/Operator-types,-precedence,-and-associativity","Term-1-Year-1/CCPROG1/Float-and-integer-operations","Term-1-Year-1/CCPROG1/Problem-analysis,-logic-formulation-and-flowcharting"],"tags":["ccprog1"],"content":"See also: FAQ\nC is a general-purpose procedural programming language. C is one of the many programming languages that can be used to create programs and it remains to be a popular programming language in the academe and the IT industry. C and its descendants were used to create operating systems like UNIX and Windows as well as other popular software applications.\nA programming language is a formal language that is used to give instructions to a computer in the form of a program or code. Like any natural language, C has its own set of vocabulary and grammar. The words in C are called tokens and the grammar is called syntax.\nTokens §\n\nC programs are composed of a sequence of characters that are grouped by a compiler into identifiable tokens. These groups of characters cannot be split up without changing their meaning. Tokens can generally be classified into literals (numeric, character, and string), identifiers, operators, keywords, and separators (punctuation). For example, consider the statement:\nprintf(&quot;Height: %d\\n&quot;, height);\nThis statement consists of seven tokens:\nprintf         // Identifier\n(              // Seperator / punctuation\n&quot;Height: %d\\n&quot; // String literal\n,              // Separator / punctuation\nheight         // Identifier\n)              // Separator / punctuation\n;              // Separator / punctuation\nNote that any amount of space—blanks, tabs, and newline characters—can be placed between tokens.\n\nLiterals §\nLiterals are used to represent fixed values and can generally be classified as numeric or non-numeric. They have a value and a data type, but are nonaddressable; i.e., they are stored in memory but there are no means of accessing that address. Examples include 1, 2.5, &#039;a&#039;, or &quot;Hello, world!&quot;.\n\nNumeric literals or numeric constants §\nNumeric literals can be further subdivided into integers and floating-point numbers. int values do not contain any fractional part (as “whole numbers”). float values, on the other hand, do contain fractional parts and can be expressed in scientific notation. In defining numeric constants, the following rules should be followed:\n\nNo comma.\nNo space between the unary sign (+ or -) and the digits.\nMust begin and end with a digit.\n\nIn macro-definitions defined in preprocessor directives, floating-point values are interpreted as double-precision (double) unless specified otherwise by appending f to the value.\n\n\n\n\nCharacter literals §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEscape sequenceRepresented character\\aAlert\\bBackspace\\eEscape character (non-standard)\\fFormfeed page break\\nNewline (line feed)\\rCarriage return\\tHorizontal tab\\vVertical tab\\\\Backslash\\&#039;Single quote (apostrophe)\\&quot;Double quote\\?Question mark\\0Null character%%Percent symbol\n\n\n\n\nA character literal is a single character enclosed in single quotes(&#039;). Examples include &#039;a&#039;, &#039;I&#039;, &#039;+&#039;, &#039;2&#039; Note that there are some special characters that require using a backslash (\\; as used in escape sequences seen in the table above) or a percentage symbol (%; as used in placeholders such as in formatted input/output).\n\nCommon escape sequences covered within CCPROG1 are highlighted in bold.\n\n\nString literals §\nA series of characters is called a string. A string literal should be enclosed in double-quotes (&quot;&quot;). Note that certain special characters also need the escape character backslash (\\) inside the double-quotes, e.g., \\&quot; for including a double-quote character within the string.\nExamples:\n\n&quot;De La Salle University&quot;\n&quot;a string with double quotes \\&quot; within&quot;\n&quot;a single backslash \\\\ is in this string&quot;\n\n\nIdentifiers §\nIdentifiers are descriptive names that are given to the variables, constants, and other entities in our program. Identifiers are a sequence of letters, digits, and the special character _ (underscore). They are defined by the programmer and as such should be descriptive. Although C places no limit on the maximum length of an identifier (albeit compilers are only required to remember the first 63 characters in C99), avoid using names that are too short or too long. Limit the identifiers from 8 to 15 characters only.\nThere are some rules and guidelines for defining identifiers. They are as follows:\n\nIt must consist only of letters, digits, and underscores.\nAn identifier cannot begin with a digit.\nAn identifier defined in the C standard library should not be redefined. Keywords or reserved words are also invalid identifiers.\nIdentifiers are case sensitive, meaning uppercase is not equal to the lowercase.\n\n\nHungarian notation §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nData TypePrefixintnlonglfloatfdoubledcharc\n\n\n\n\nAs a convention, we add prefixes in our variables to easily identify their data type. This is referred to as Hungarian notation.\n\nConstants §\nConstants are entities that can store a value but cannot be changed. Usually, constant identifiers are written using all capital letters with underscores between each word. It is suggested that we use all capital letters when naming constants to distinguish them from variables.\nExamples:\n\nMAX\nNUM_STUDENTS\nConstants are usually defined at the beginning of a program:\n\n #define &lt;constant identifier&gt; &lt;literal&gt;\n\n\nOperators §\nAn operator is a symbol in C that is used to perform certain operations on values or variables. For example, the arithmetic operators: *, /, %, +, and - correspond to the operations: multiplication, division, modulo, addition, and subtraction, respectively. Furthermore, evaluating operators follows a hierarchy of priorities. Note that the data type (whether it is an integer or floating-point number) of the operands affects the result of the operation. The three basic types of operators are:\n\nArithmetic operators\nRelational operators (i is greater than 0)\nLogical operators (i is greater than 0 and less than 10)\n\n\nKeywords §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nKeywordDefinitionautoSpecifies automatic storage duration for a variable.breakUsed to exit from a loop or switch statement.caseUsed to label values in a switch statement.charData type to store character values.constDeclares a variable as constant, preventing modification.continueJumps to the next iteration in a loop.defaultSpecifies the code to be executed in a switch statement if no case matches.doLooping construct that executes a block of code at least once.doubleData type to store double-precision floating-point numbers.elseUsed to specify the alternative code in an if statement.enumDefines an enumeration type with symbolic constants.externDeclares a variable or function that is defined in another source file.floatData type to store floating-point numbers.forUsed to create a loop with initialization, condition, and increment parts.gotoTransfers control to a labeled statement.ifConditional statement for making decisions.intData type to store integers.longUsed to declare a variable with an extended range.registerSuggests that a variable should be stored in a register.returnReturns a value from a function.shortData type to store integers with a smaller range.signedSpecifies the sign of a data type, can be positive or negative.sizeofReturns the size in bytes of a data type or object.staticSpecifies that a variable retains its value between function calls.structDefines a composite data structure with multiple members.switchA control statement for multi-way branching.typedefUsed to create new data types with type aliases.unionA data structure that can store different data types.unsignedData type modifier for integers, representing only positive values.voidRepresents an empty data type or return type of a function that doesn’t return anything.volatileSuggests that a variable’s value can change unexpectedly.whileLooping construct that repeatedly executes a block of code.\n\n\n\n\nKeywords are words that have a special meaning in C. Reserved words are words that cannot be used as identifiers. Most of the keywords in C are also reserved words, therefore cannot be used to name entities in your program such as variables.\n\nSeparators or punctuation §\nThere are some symbols in C that are used to separate tokens; these are called separators. Spaces, tabs, and newlines (also called whitespaces) are also used to separate tokens but are not tokens themselves.\nExamples:\n, ; : { }\n\nComments §\nComments are not processed as tokens and are usually ignored by the compiler, replacing them with a single space charaacter; i.e., a statement such as:\na/**/b = 0;\n—will be interpreted as:\na b = 0;\nComments are processed before preprocessing directives are executed. The main use of comments is to make the code more readable and understandable by explaining part of the code in natural language. Usually, introductory comments are added to the beginning of a code that contains the name of the author, the date it was written, and any assumptions made by the programmer. This is not required but it is recommended for good programming practice.\nThe symbols /* signify the start of the comment, while */ signify the end of the comment. A comment enclosed in /* */ can encompass more than one line. Comments may also appear within the main program or in functions to explain code.\n\nSingle-line comments denoted by // are only possible in version C99 and later. Comments enclosed in /* */ cannot be nested inside each other, but comments denoted by // can be nested inside /* */.\n\n\n\n\n"},"Term-1-Year-1/CCPROG1/Variables-and-assignment":{"title":"Variables and assignment","links":["Term-1-Year-1/CCICOMP/Data-representation","Term-1-Year-1/CCPROG1/Operator-types,-precedence,-and-associativity","Term-1-Year-1/CCICOMP/Character-representation"],"tags":["ccprog1"],"content":"Variables §\nVariables are entities that can store a value that can be changed during the execution of a program. They have accessible memory addresses and as such can be used as the left operand in an assignment operation. These can be of different types of data. They can store constant values/literals or some type of structured data, which can contain one or more values or data.\n\nDeclaration §\nVariables are usually declared before the start of the program code. The variable declarations tell the C compiler what type of data will be stored in each variable and how that data will be represented in memory. Variables must be declared before they are used. The syntax for declaring variables are as follows:\n&lt;data type&gt; &lt;variable or variable list&gt;\n\nFor instance, a variable num with type int will be declared as follows:\nint num;\nA series of variables of the same type can be declared at the same time. To do this, the variables are separated by commas:\nint num1, num2;\nfloat flo1, flo2;\nAlthough the following example shows that multiple variables in one declaration statement are possible, it is still best to declare one variable per declaration statement for readability.\n\nInitialization §\nVariables that do not have a default value and have not been assigned one are said to be uninitialized. A variable may be initialized by assigning it a value during its declaration:\nint num = 1;\nSeveral initializations (for variables of the same type) may be performed in one statement, separated by commas:\nint num1 = 1, num2 = 2, num3 = 3;\n\nAttempting to access the value of an uninitialized variable will result in garbage (unpredictable) values.\n\n\nAssignment §\nOnce a variable has been declared, it can be assigned a value.\n\nData type ranges §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nData typeRangeint-2147483648 to +2147483647long-2147483648 to +2147483647float3.4e-38 to 3.4e38double1.7e-308 to 1.7e308\n\n\n\n\nData types in C store values within specific ranges. The type affects how the variable is stored and what operations can be performed on the variable.\nAt the moment, the data types that we consider are integers, floating-point numbers, and characters.\nThe keywords int or long are used to define the integer data type:\nint x = 1;\nOn the other hand, float and double are used to define floating-point numbers or double-precision numbers (the difference is in the range of numbers it can accommodate):\nfloat x = 1.0;\ndouble y = 1.0;\nA character data type is denoted by the keyword char. It requires one byte of memory space and the range of values is from 0 to 255 encoded in ASCII.\nchar x = &#039;a&#039;;\nThe amount of memory space required to store an int, a float, and double are platform-dependent (i.e., depends on the machine and the software). The table shown above is for Linux systems.\n"},"Term-2-Year-2/CCDSTRU/Equivalences":{"title":"Equivalences","links":[],"tags":["ccdstru"],"content":"Tautology §\nA compound proposition whose truth value is always true is called a tautology or a fact.\n\nContradiction §\nA compound proposition whose truth value is always false is called a contradiction or a fallacy.\n\nContingency §\nA compound proposition whose truth value is not a tautology nor a contradiction is called a contingency.\n\nLogical equivalence rules §\nIdentity §\np∧T≡p\np∨F≡p\n\nDomination §\np∧F≡F\np∨T≡T\n\nNegation §\np∧¬p≡F\np∨¬p≡T\n\nIdempotence §\np∧p≡p\np∨p≡p\n\nInvolution §\n¬(¬p)≡p\n\nDe Morgan’s §\n¬(p∧q)≡¬p∨¬q\n¬(p∨q)≡¬p∧¬q\n\nCommutative §\np∧q≡q∧p\np∨q≡q∨p\n\nAssociative §\np∧(q∧r)≡(p∧q)∧r\np∨(q∨r)≡(p∨q)∨r\n\nAbsorption §\np∧(p∨q)≡p\np∨(p∧q)≡p\n\nMaterial implication §\np→q≡¬p∨q\n\nMaterial equivalence §\np↔q≡(p→q)∧(q→p)\np↔q≡(p∧q)∨(¬p∧¬q)\n"},"Term-2-Year-2/CCDSTRU/Predicate-logic":{"title":"Predicate logic","links":["Term-2-Year-2/CCDSTRU/Propositional-logic","Term-2-Year-2/CCDSTRU/Equivalences"],"tags":["ccdstru"],"content":"Predicate logic §\nPredicate logic is a more powerful type of logic that allows us to reason and explore object relationships\n\nPredicates §\nGiven the statement\nx is greater than 5\nwhere the variable is the subject of the statement (x), the predicate refers to the property that the variable can have (“greater than 5”).\n\nPropositional functions §\nLet P(x)=x is greater than 5\nP(x) is not a proposition but will be once x has a value, e.g:\nP(4)=FP(10)=T​\nP(x1​,x2​,...,xn​) is therefore the value of the propositional function P at the n-tuple (x1​,x2​,...,xn​) (a.k.a. n-ary predicate or n-place predicate).\n\n\n                  \n                  Convention: \n                  \n                \nUppercase letters for propositional functions, and lowercase letters for propositions.\n\n\nConverting propositional functions into propositions §\nA propositional function whose variables do not have specific values is not a proposition. There are two ways wherein we can convert propositional functions into propositions:\n\nValue assignment, e.g., P(5), P(−1)\nQuantification\n\n\nQuantification §\nQuantification expresses the extent to which the predicate is true over a range of elements. The use of English words some, all, none are used in quantification.\n\nUniversal quantification §\nExpresses that the predicate is true for all elements in a given domain. English words used to express such are all, every, and each.\nThe universal quantification of P(x) is the statement ”P(x) is true for all values of x in the domain,” or:\n∀xP(x)≡P(x1​)∧P(x2​)∧...∧P(xn​)​\nwhere x1​,x2​,...,xn​ are all the elements in the domain.\n\n\n                  \n                  An element for which P(x) is false is called a counterexample.\n                  \n                \n\n\nExistential quantification §\nExpresses that the predicate is true for at least one of the elements in a given domain. English words used to express such are some, at least one, and there exists.\nThe existential quantification of P(x) is the statement ”P(x) is true for at least one value of x in the domain,” or:\n∃xP(x)≡P(x1​)∨P(x2​)∨...∨P(xn​)​\nwhere x1​,x2​,...,xn​ are all the elements in the domain.\n\nNested quantifiers §\nTwo quantifiers are nested if one is within the scope of the other.\nFor instance, ∀x∃y(x+y=0) is translated as “For all x, there exists y such that x+y=0”\nGiven that the domain for x is {1,2,3,4} and the domain for y is {a,b,c,d}:\n\n\nNegating quantifiers §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNegationEquivalent statement¬∃xP(x)∀x¬P(x)¬∀xP(x)∃x¬P(x)\n\n\n\n\nThe rules for negations for quantifiers are called De Morgan’s laws for quantifiers.\n"},"Term-2-Year-2/CCDSTRU/Propositional-logic":{"title":"Propositional logic","links":[],"tags":["ccdstru"],"content":"Proposition §\nA proposition is a declarative sentence that is either true or false, but not both.\nAll the following declarative sentences are propositions; propositions 1 and 3 are true, whereas 2 and 4 are false.\n\nWashington, D.C., is the capital of the United States of America.E\nToronto is the capital of Canada.\n1 + 1 = 2.\n2 + 2 = 3.\n\n\nPropositional variables §\nWe use letters to denote propositional variables (or sentential variables), that is, variables that represent propositions, just as letters are used to denote numerical variables.\n\n\n                  \n                  When declaring propositional variables, use simple (atomic) propositions. Avoid operators in declarations. \n                  \n                \n\n\nTruth value §\nThe truth value of a proposition is true, denoted by T, if it is a true proposition, and false, denoted by F, if it is a false proposition.\n\nCompound propositions §\nFormed from existing propositions using logical operators\n\nLogical operators §\nOperators that take existing propositions to form compound propositions\n\nTruth table §\nA table consisting of n input columns, an output column, and xn rows, where x is the number of possible values (true or false means 2 values) and n is the number of variables\n\nNegation (NOT) §\n\n¬p (read as “not p“)\nUnary operator (takes only one operand)\n¬p is translated as “It is not the case that p”\nExample:\n\np: “I sleep early”\n¬p: “I do not sleep early”\n\n\n\n\nNegation truth table §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\np¬pTFFT\n\nConjunction (AND) §\n\np∧q (read as ”p and q“)\nBinary operator (takes two operands)\nTrue if and only if p and q are both true\nExample:\n\np: “I will sleep early tonight”\nq: “I will eat breakfast tomorrow morning”\np∧q: “I will sleep early tonight and eat breakfast tomorrow morning”\n\n\n\n\nConjunction truth table §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npqp∧qTTTTFFFTFFFF\n\nDisjunction (Inclusive OR) §\n\np∨q (read as ”p or q“)\nBinary operator (takes two operands)\nTrue if at least one operand is true\nExample:\n\np: “I wake up early”\nq: “I am late for class”\np∨q: “I wake up early or I am late for class”\n\n\n\n\nDisjunction truth table §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npqp∨qTTTTFTFTTFFF\n\nExclusive or (XOR) §\n\np⊕q (read as ”p xor q“)\nBinary operator (takes two operands)\nTrue if either p or q is true, but not both (i.e., p and q must have different truth values)\nExample:\n\np: “The steak comes with soup”\nq: “The steak comes with dessert”\np⊕q: “The steak comes with soup or dessert, but not both”\n\n\n\n\n\n                  \n                  Assume inclusive or unless stated otherwise. \n                  \n                \n\n\nExclusive or truth table §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npqp⊕qTTFTFTFTTFFF\n\nImplication (conditional) §\n\np→q (read as ”p implies q”, or “if p then q“)\np is the premise, q is the consequence\n\nIf the premise happened, then so will the consequence.\n\n\nIn other words:\n\np is sufficient for q\nq is necessary for p\nq whenever p\n\n\n\n\nImplication truth table §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npqp→qTTTTFFFTTFFT\n\nConverse §\n\nThe converse of p→q is q→p\nEquivalent to the inverse\n\n\nInverse §\n\nThe inverse of p→q is ¬p→¬q\nEquivalent to the converse\n\n\nContrapositive §\n\nThe contrapositive of p→q is ¬q→¬p\nEquivalent to the original statement\n\n\nBiconditional (IFF) §\n\np↔q (read as ”p if and only if q” or ”p is sufficient and necessary for q“)\nTrue if p→q and q→p are both true (i.e., p and q have the same truth value)\n\n\nBiconditional truth table §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npqp→qTTTTFFFTFFFT\n"},"Term-2-Year-2/CCDSTRU/Rules-of-inference":{"title":"Rules of inference","links":[],"tags":["ccdstru"],"content":"Argument §\nAn argument in propositional logic is a sequence of propositions.\n\nPremises §\nAll statements in an argument except the last.\n\nConclusion §\nThe final argument in the list.\n\nRules of inference §\nConjunction §\n​pq∴p∧q​\n\nSimplification §\n​p∧q∴p​\n\nAddition §\n​p∴p∨q​\n\nResolution §\n​p∨q¬p∨r∴q∨r​\n\nHypothetical syllogism §\n​p→qq→r∴p→r​\n\nModus ponens §\n​pp→q∴q​\n\nDisjunctive syllogism §\n​p∨q¬p∴q​\n\nModus tollens §\n​¬qp→q∴¬p​\n\nRules of inference for quantified statements §\nUniversal instantiation §\n​∀xP(x)∴P(c) where c∈u​\n\nExistential instantiation §\n​∃xP(x)∴P(c) for some element c where c∈u​\nUsually we have no knowledge of what c is, only that it exists. Because it exists, we may give it a name (c) and continue our argument.\n\nUniversal generalization §\n​P(c) for an arbitrary c where c∈u∴∀xP(x)​\n\n\n                  \n                  Warning c must be an arbitrary, not a specific element of the domain. We have no control over c and cannot make any other assumptions about c other than it comes from the domain\n                  \n                \n\n\nExistential generalization §\n​P(c) for some element c where c∈u∴∃xP(x)​\nIf we know one element c in the domain for which P(c) is true, then we know that ∃xP(x) is true.\n"},"Term-2-Year-2/CCDSTRU/Set-identities":{"title":"Set identities","links":[],"tags":["ccdstru"],"content":"Identity §\nA∩U=A\nA∪∅=A\n\nDomination §\nA∩∅=∅\nA∪U=U\n\nIdempotence §\nA∩A=A\nA∪A=A\n\nComplement §\nA∩Aˉ=∅\nA∪Aˉ=U\n\nComplementation §\nAˉˉ=A\n\nDe Morgan’s §\nA∩Bˉ=Aˉ∪Bˉ\nA∪Bˉ=Aˉ∩Bˉ\n\nCommutative §\nA∩B=B∩A\nA∪B=B∪A\n\nAssociative §\nA∩(B∩C)=(A∩B)∩C\nA∪(B∪C)=(A∪B)∪C\n\nDistributive §\nA∩(B∪C)=(A∩B)∪(A∩C)\nA∪(B∩C)=(A∪B)∩(A∪C)\n\nAbsorption §\nA∩(A∪B)=A\nA∪(A∩B)=A\n"},"Term-2-Year-2/CCDSTRU/Set-operations":{"title":"Set operations","links":[],"tags":["ccdstru"],"content":"Cartesian product §\nThe cartesian product of A and B, denoted by A×B, is the set of all ordered pairs (a,b) such that a∈A and b∈B.\nA×B={(a,b)∣a∈A∧b∈B}\nLet A={1,2,3} and B={a,b}:\n​A×B={(1,a),(1,b),(2,a),(2,b),(3,a),(3,b)}B×A={(a,1),(a,2),(a,3),(b,1),(b,2),(b,3)}​\n\n\n                  \n                  Note that: \n                  \n                \n\nA×B=B×A, unless A=∅ or B=∅ or A=B (i.e. it is not commutative)\n(A×B)×C=A×B×C (i.e. it is not associative)\n∣A×B∣=∣A∣∣B∣\nAn denotes the cartesian product of A with itself n times.\n\n\n\nUnion §\nA∪B={x∣x∈A∨x∈B}\n\n\n                  \n                  Principle of inclusion-exclusion \n                  \n                \nNote that ∣A∣+∣B∣ counts each element that is in A but not in B or in B but not in A exactly once, and each element that is in both A and B exactly twice. Thus, if the number of elements that are in both A and B is subtracted from ∣A∣+∣B∣, elements in A∩B will be counted only once. Hence, ∣A∪B∣=∣A∣+∣B∣−∣A∩B∣.\n\n\nIntersection §\nA∩B={x∣x∈A∧x∈B}\n\n\n                  \n                  If A∩B=∅, A and B are disjoint sets.\n                  \n                \n\n\nDifference §\nA−B={x∣x∈A∧x∈/B}\n\nComplement §\nAˉ={x∈U∣x∈/A}\n"},"Term-2-Year-2/CCDSTRU/Set-theory":{"title":"Set theory","links":[],"tags":["ccdstru"],"content":"Set §\nA set is an unordered collection of objects, called elements or members:\na∈A denotes that a is an element of set A.\na∈/A denotes that a is not an element of set A.\n\n\n                  \n                  Convention \n                  \n                \nUppercase letters are used to name sets, while lowercase letters are used to indicate elements of a set.\n\n\nRoster method §\nA way of describing a set involving listing all the members of a set, when possible. All members of the set are listed between braces.\n​V={a,e,i,o,u}A={1,2,3,…}B={2,4,6,…,20}​\n\nSet builder §\nCharacterizing all elements in the set by stating the property or properties they must have to be members.\n​V={x∣x is a vowel}A={x∣x∈Z+}B={x∈Z+∣xmod2=0∧x≤20}​\n\n\n                  \n                  Note that the third example specifies the set of positive integers as the universe.\n                  \n                \n\n\nVenn diagrams §\nIn Venn diagrams, the universal set U, which contains all the objects under consideration, is represented by a rectangle. Inside this rectangle, circles or other geometrical figures are used to represent sets. Sometimes, points are used to represent the particular elements of the set.\n\n\nImportant sets §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSymbolDescriptionContentsNThe set of natural numbers{0,1,2,3,…}ZThe set of integers{…,−3,−2,−1,0,1,2,3,…}Z+The set of positive integers{1,2,3,…}Z−The set of negative integers{…,−3,−2,−1}QThe set of rational numbers{qp​∥p∈Z∧q∈Z∧q=0}CThe set of complex numbers\n\n\n\n\n\n\n                  \n                  There is no general agreement whether 0 is included in N.\n                  \n                \n\n\nNull set §\nA set that contains no elements is called an empty set or null set, denoted by ∅ or {}.\n\nSingleton set §\nA set that contains exactly one element is called a singleton set.\n\n\n                  \n                  Note that ∅={∅}. ∅ is a null set, while {∅} is a singleton set containing ∅.\n                  \n                \n\n\nCardinality §\nThe number of distinct elements in a set S is known as the cardinality of S or ∣S∣\n\nEqual sets §\nTwo sets A and B are equal if and only if they have the same elements.\nA=B↔∀x(x∈A↔x∈B)\n\n\n                  \n                  The order of elements and the number of times each element occurs in the set do not matter. \n                  \n                \n\n\nSubset §\nSet A is a subset of set B if and only if every element of A is also in B.\nA⊆B↔∀x(x∈A→x∈B)\n\nProper subset §\nSet A is a proper subset of set B if and only if every element of A is also in B, but A=B; i.e., there exists an element of B that is not in A.\nA⊂B↔∀x(x∈A→x∈B)∧∃x(x∈B∧x∈/A)\n\nPower set §\nThe power set of S is the set of all subsets of S, denoted by P(S).\nLet A={1,2,3}:\nP(A)={∅,{1},{2},{3},{1,2},{1,3},{2,3},{1,2,3}}\n\n\n                  \n                  Note that ∣P(S)∣=2∣S∣.\n                  \n                \n\n"},"Term-2-Year-2/CSMATH1/Infinite-limits-and-limits-at-infinity":{"title":"Infinite limits and limits at infinity","links":[],"tags":["csmath1"],"content":"Infinite limit theorems §\nxr1​ where r∈Z (17) §\nlimx→0+​xr1​ §\nx→0+lim​xr1​=+∞\n\nlimx→0−​xr1​ §\nx→0+lim​xr1​={−∞,+∞,​if r is oddif r is even​\n\nf(x)g(x)​ where a∈R∧limx→a​f(x)=0∧limx→a​g(x)=c=0 (18) §\nc&gt;0∧f(x)→0 through positive values of f(x) (18i) §\nx→alim​f(x)g(x)​=+∞\n\nc&gt;0∧f(x)→0 through negative values of f(x) (18ii) §\nx→alim​f(x)g(x)​=−∞\n\nc&lt;0∧f(x)→0 through positive values of f(x) (18iii) §\nx→alim​f(x)g(x)​=−∞\n\nc&lt;0∧f(x)→0 through negative values of f(x) (18iv) §\nx→alim​f(x)g(x)​=+∞\n\nTheorems concerning operations between infinite limits and constant limits §\nAddition of infinite limit and constant limit (19) §\nx→alim​f(x)=+∞∧x→alim​g(x)=cx→alim​[f(x)+g(x)]=+∞​\nLikewise,\nx→alim​f(x)=−∞∧x→alim​g(x)=cx→alim​[f(x)+g(x)]=−∞​\n\nMultiplication of infinite limit and constant limit (20, 21) §\nx→alim​f(x)=+∞∧x→alim​g(x)=cc&gt;0→x→alim​[f(x)g(x)]=+∞c&lt;0→x→alim​[f(x)g(x)]=−∞​\nLikewise,\nx→alim​f(x)=−∞∧x→alim​g(x)=cc&gt;0→x→alim​[f(x)g(x)]=−∞c&lt;0→x→alim​[f(x)g(x)]=+∞​\n\nVertical asymptotes §\nThe line x=a is a vertical asymptote of the graph of the function f if at least one of the following is true:\nx→a+lim​f(x)=+∞x→a+lim​f(x)=−∞x→a−lim​f(x)=+∞x→a−lim​f(x)=−∞​\n\nLimits at infinity theorems §\nlimx→+∞​xr1​ (22) §\nr∈Z→x→+∞lim​xr1​=0=x→−∞lim​xr1​\n\nHorizontal asymptote §\nThe line y=b is a horizontal aymptote of the graph of the function f if at least one of the following statements is true:\nx→+∞lim​f(x)=b∧∃N(x&gt;N→f(x)=b)x→−∞lim​f(x)=b∧∃N(x&gt;N→f(x)=b)​\n"},"Term-2-Year-2/CSMATH1/Limits":{"title":"Limits","links":[],"tags":["csmath1"],"content":"Informal definition of a limit §\nLet f(x) be defined on an open interval containing a, except possibly at a itself. If f(x) gets arbitrarily close to L for all x sufficiently close to a, we say that f(x) approaches the limit L as x approaches a, and we write:\nx→alim​f(x)=L\n\n\n                  \n                  A function may fail to have a limit at a point in its domain. \n                  \n                \n\n\nFormal (ϵ-δ) definition of a limit §\nLet f(x) be a function defined at every number in some open interval containing a, except possibly at the number a itself.\nx→alim​f(x)=L\n—if and only if…\nGiven any ϵ&gt;0, however small, there exists a δ&gt;0 such that:\n0&lt;∣x−a∣&lt;δ→∣f(x)−L∣&lt;ϵ\n\nShow that limx→3​f(x)=1 given f(x)=2x−5 §\nWe must show that:\n0&lt;∣x−3∣&lt;δ→∣(2x−5)−1∣&lt;ϵ\nOr, equivalently:\n0&lt;∣x−3∣&lt;δ→2∣x−3∣&lt;ϵ≡0&lt;∣x−3∣&lt;δ→∣x−3∣&lt;2ϵ​​\nGiven δ=2ϵ​≡2δ=ϵ:\n0&lt;∣x−3∣&lt;δ→2∣x−3∣&lt;2δ≡0&lt;∣x−3∣&lt;δ→2∣x−3∣&lt;22ϵ​≡0&lt;∣x−3∣&lt;δ→2∣x−3∣&lt;ϵ∴x→3lim​f(x)=1​\n\nShow that limx→2​f(x)=4 given f(x)=x2 §\nWe must show that:\n0&lt;∣x−2∣&lt;δ→∣x2−4∣&lt;ϵ\nOr, equivalently:\n0&lt;∣x−2∣&lt;δ→∣x+2∣∣x−2∣&lt;ϵ\n\nLimit theorems §\nLimit of a linear function (1) §\nIf m and b are constants, then\nx→alim​mx+b=ma+b\n\nLimit of a constant (2) §\nIf c is a constant\nx→alim​c=c\n\nLimit of the identity function (3) §\nx→alim​x=a\n\nLimit of the sum and difference of n functions (4, 5) §\nx→alim​f1​(x)=L1​,x→alim​f2​(x)=L2​,...,x→alim​fn​(x)=Ln​→x→alim​[f1​(x)±f2​(x)±...±fn​(x)]=L1​±L2​±...±L3​​\n\nLimit of the product of n functions (6, 7) §\nx→alim​f1​(x)=L1​,x→alim​f2​(x)=L2​,...,x→alim​fn​(x)=Ln​→x→alim​[f1​(x)f2​(x)...fn​(x)]=L1​L2​...L3​​\n\nLimit of the nth power of a function (8) §\n[x→alim​f(x)=L]∧(n∈Z+)→x→alim​[f(x)]n=Ln​\n\nLimit of the quotient of two functions (9) §\n[x→alim​f(x)=L]∧[x→alim​f(x)=L]∧(M=0)→x→alim​g(x)f(x)​=ML​​\n\nLimit of the nth root of a function (8) §\n[x→alim​f(x)=L]∧(n∈Z+)∧(n∈2Z+→L&gt;0)→x→alim​nf(x)​=nL​​\n\nOne-sided limits §\nRight-hand limit §\nx→a+lim​f(x)=L\n—if and only if…\nGiven any ϵ&gt;0, however small, there exists a δ&gt;0 such that:\n0&lt;x−a&lt;δ→∣f(x)−L∣&lt;ϵ\n\nLeft-hand limit §\nx→a−lim​f(x)=L\n—if and only if…\nGiven any ϵ&gt;0, however small, there exists a δ&gt;0 such that:\n0&lt;a−x&lt;δ→∣f(x)−L∣&lt;ϵ\n\nTwo-sided limit §\nx→alim​f(x) exists and is equal to L↔x→a+lim​f(x) and x→a+lim​f(x) both exist and are equal to L.\n"},"Term-2-Year-2/GEMATMW/Fibonacci-sequence-and-the-golden-ratio":{"title":"Fibonacci sequence and the golden ratio","links":[],"tags":["gematmw"],"content":"Fibonacci sequence §\nThe Fibonacci sequence is agiven by:\n1,1,2,3,5,8,13,21,34,55,89,...\n\n\n                  \n                  Each term, except the first two which are both 1, is obtained by adding the previous two terms\n                  \n                  \n                \n                \n\n\n\n\nChoose any term in the sequence and square it\n\n\nMultiply the terms on both sides of the chosen number\n\n\nSubtract the smaller result from the larger result\n\n\n13 -&gt; 13^2 = 169 -&gt; 8 * 21 = 168 -&gt; 169 - 168 = 1\n\nChoose any term in the sequence and square it\nMultiply the terms 2 positions away from the chosen number\nSubtract the smaller result from the larger result\n\n13 -&gt; 13^2 = 169 -&gt; 5 * 34 = 170 -&gt; 170 - 169 = 1\n\nChoose any term in the sequence and square it\nMultiply the terms 3 positions away from the chosen number\nSubtract the smaller result from the larger result\n\n13 -&gt; 13^2 = 169 -&gt; 3 * 55 = 165 -&gt; 169 - 165 = 4\nA golden rectangle is defined to be a rectangle whose length (L) and width ( HI) satisfy the following proportion:\nWL​=LL+W​\nThe ratio WL​ is called the Golden Ratio\nLetWL​=ϕ\nThen, from the proportion of the golden rectangle, we have\nϕ=1+ϕ1​\nϕ2=ϕ+1\nTherefore:\nϕ=21±1+4​​=21±5​​\nNotably:\nn→∞lim​Fn​Fn+1​​=21±5​​"},"Term-2-Year-2/GEMATMW/Geometric-transformations":{"title":"Geometric transformations","links":[],"tags":["gematmw"],"content":"Reflection §\nThe original figure has a mirror image that is of the same distance on the other side of the axis of reflection.\n\nReflection across the x-axis §\nPoint (a,b) is shifted into (a,−b)\n\nReflection across the y-axis §\nPoint (a,b) is shifted into (−a,b)\n\nReflection across the line y=x §\nPoint (a,b) is shifted into (b,a)\n\nTranslation §\nIn a translation or a slide, all the points in the figure are moved the same distance and the same direction.\nIf (a,b) is slid c units horizontally and d units vertically, (a,b) is shifted into (a+c,b+d). In other notation, T(c,d)​\n\nGlide reflection §\nIt is a transformation that is formed by first applying reflection across an axis and then translation in the same direction as the axis.\n\nRotation §\nIt is a transformation that turns a figure about a fixed point called the center of rotation. A rotation is sometimes called a turn.\n\n90-degree rotation given center (0,0) §\n(x,y) is rotated into (−y,x)\n\n180-degree rotation given center (0,0) §\n(x,y) is rotated into (−x,−y)\n\n270-degree rotation given center (0,0) §\n(x,y) is rotated into (y,−x)\n\nθ-degree rotation counter-clockwise given center (0,0) §\n(x,y) is rotated into (xcosθ−ysinθ,xsinθ+ycosθ)\n\nRotational symmetry §\nIf a geometric figure has a rotational symmetry, the order of its rotational symmetry is defined as the number of times it matches with itself as it is rotated around a full circle.\n\nDilation §\nA transformation such that (x,y) dilates into (kx,ky) where k is a nonzero constant known as the scale factor. The original figure and its image are similar but of different sizes if k≤1\n\nExpansion §\nDilation where k&gt;1\n\nContraction §\nDilation where 0&lt;k&lt;1\n"},"Term-2-Year-2/LCFILIA/Philippine-Studies-and-Pilipinolohiya":{"title":"Philippine Studies and Pilipinolohiya","links":[],"tags":[],"content":"\nExternal and internal point of view\n\nExternal: Philippine Studies (Pag-aaral tungkol sa Pilipinas)\nInternal: Pilipinolohiya\n\n\n98% of historical sources are in foreign tongues\nPropaganda Movement attempted to create a counter-consciousness with an idea of nationality (albeit in Spanish)\n\n\n\n                  \n                  The idea of the Philippines as an area of study resulted from the intellectual encounter between the Philippines and Europe, i.e., between Rizal and his fellow Propagandists and European scholars such as Blumentritt. \n                  \n                \n\n\n\n                  \n                  ...surprise you with a grand news. Now everything is ready. We have formed an Association Internationale des Philippinistes of which you should be the president. \n                  \n                \n\n\n\n                  \n                  In Barcelona I visited the Filipino colony - Ponce, Cánon, Graciano, and others were very amiable towards me. We certainly talked a great deal about you. You are the personification of kindliness to my countrymen. It is wonderful for us to know a European like you. \n                  \n                \n\n\nRizal’s Association, of which he would appoint Blumentritt as president, would serve as the culmination of this intellectual encounter.\nThe Association’s Board of Directors consists of the following:\n\n\n\n                  \n                  Prof. Blumentritt (Austrian), President Edm. Plauchut (French), Vice President Counselor : Dr. Rost (Anglo-German) Counselor: Dr. Regidor (Mestizo Filipino) Secretary: Dr. Rizal (Malayan-Tagalog) \n                  \n                \n\n\nBlumentritt would accept the position, though with some reservation:\n\n\n\n                  \n                  I have received your letter and I am most grateful to you on behalf of my country for having accepted the presidency. Do not be afraid that we would embarrass you, even if it were a matter of asking for the welfare of my country. We want the happiness of the Philippines, but we want to obtain it through noble and just means, for right is on our side and therefore we ought not to do any thing wrong. If I have to act villainously in order to make my country happy, I would refuse to do it because I am sure that what is built on sand sooner or later would tumble down. Fear nothing then. If we always confine ourselves within our rights, reason shall be on our side, despite the friars and the others: and if it is impossible for us to defeat our enemies now, one morning will come and another day will appear, for there must be a God of justice, otherwise we shall become atheists. \n                  \n                \n\n\nRizal would define the true Philippiniste, along with a criticism of the Spanish author Casal:\n\n\n\n                  \n                  I have already read Casal&#039;s book and I am very sorry that he had signed it. They have written me from Madrid that the author was a friar. Casal knows neither the Philippines nor her inhabitants. He left the Philippines as a child. He was educated in Europe, and when he returned to the Philippines, he stayed so short a time - shorter than I did - that he could not have obtained a sufficient knowledge of the condition of her inhabitants. Moreover, Casal is a happy man and he has only mingled with the happy and powerful. For that reason he is satisfied with the conditions obtaining there. He has a large income and he does not live there. Therefore, why should he undertake a quixotism to set aright wrongs and defend the helpless? His descendants will certainly be Spaniards and it would be folly to fight for the Philippines when one has his hopes pinned on Spain. \n                  \n                \n\n\nThis is contradictory to his acceptance of Blumentritt and other scholars as philippinistes.\n\nIn Rizal’s view, however, they are sympathetic to the cause.\n\n\nRizal did not consider odern Tagalog literature as contradictory to modern Filipino literature or to religious literature. Rather, they all constituted one single national literature.\nStudying the Philippines was a search for the unity of the Vaterland\n\n\n\n                  \n                  In Rizal&#039;s view, the Philippines went through: \n                  \n                \n\nA period of “autonomy” between 1521 and 1808 (which he referred to as a time of “darkness” and “decline” working on his edition of Morga’s Sucesos de las Islas Filipinas)\nA loss of this autonomy (Noli me Tangere) and an incorporation into the Spanish nation between 1808 and 1872\n\nThis crisis would be resolved only by revolution (El Filibusterismo)\n\n\n\n\n\nRizal would be founding Pilipinolohiya and leaving Philippine Studies to the European scholars.\nA Philippine Studies program would be established in the U.P. College of Arts and Sciences in 1974\n\nDisciplines were massively introduced to the Philippines through the English-language education system by the Americans\nThe main concern of the humanities was their application to the Philippine context\n\n\n\n\n\n                  \n                  Acculturation \n                  \n                \nAcculturation refers to assimilation to a different culture, typically the dominant one.\n\n\nThe importation of American disciplines along with the educational system itself constituted an unprecedented acculturative phenomenon with the entry into the socio-cultural fabric of a new language (English) with different norms of behavior and patterns of thought\n\nThis process, from the point of view of the American colonial regime, can be called “social engineering in the Philippines”\nThe introduction of Philippine Studies results from the momentum of this regime, perpetuated by Americanized Filipinos and carried on the back of the concept of area studies.\n\n\n\n\n\n                  \n                  Area studies \n                  \n                \nArea studies (also known as regional studies) are interdisciplinary fields of research and scholarship pertaining to particular geographical, national/federal, or cultural regions.\n\n\n\n                  \n                  Continue from page 309 \n                  \n                \n"},"index":{"title":"Hello.","links":[],"tags":[],"content":"\n\n\n「あたしのままで、あたしがここにいることが恐くない。」\n\nIf images or other attachments aren&#039;t loading, refresh the page. Don&#039;t know why Quartz does that.\nGoogle Drive\n"}}